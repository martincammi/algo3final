\documentclass[11pt, a4paper, spanish]{article}

\usepackage{alltt}

%%%%%%%%%% COMIENZO DEL PREAMBULO %%%%%%%%%%

%Info sobre este documento
\author{Mart\'n Cammi}
\title{Trabajo Pr\'actico de Algoritmos y Estucturas de datos III}

%\usepackage{infostyle}                                                  % provee un look & feel similar a un documento Word
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}  % m\'argenes
\usepackage[ansinew]{inputenc}                                           % permite que los acentos del estilo \'a\'e\'i\'o\'u salgan joya
\usepackage[spanish, activeacute]{babel}                                 % idioma espa�ol, acentos f\'aciles y deletreo de palabras
\usepackage{indentfirst}                                                 % permite indentar un parrafo a mano
\usepackage{caratula}                                                    % incluye caratula est\'andar
\usepackage{graphicx}                                                    % permite insertar gr\'aficos
\usepackage{color}                                                       % permite el uso de colores en el documento
\usepackage[pdfcreator={TexLive!, LaTeX2e con TeXnicCenter},
			pdfauthor={Grupo: "1"},
			pdftitle={Algoritmos III - Trabajo Pr\'actico 1},
			pdfsubject={Trabajo Pr\'actico 1},
			pdfkeywords={Tennis, Pizza, Goldbach},
			pdfstartview=FitH,            % Fits the width of the page to the window
			bookmarksnumbered,            % los bookmarks numerados se ven mejor...
			colorlinks,                   % links con bellos colores
			linkcolor=magenta]            % permite cambiar el color de los links
			{hyperref}                    % Permite jugar con algunas cosas que aparecer\'an en el PDF final

%RESTAURAR
\usepackage{algorithm}							% Permite tabular un codigo
\usepackage{algorithmic}
%\input{spanishAlgorithmic} % mi archivo de traducci\'on			

%\selectlanguage{spanish}

%\selectlanguage{spanish}
\linespread{1.3}                    % interlineado equivalente al 1.5 l\'ineas de Word...
\pagestyle{myheadings}              %encabezado personalizable con \markboth{}{}
\markboth{}{Algoritmos III  - Trabajo Pr\'actico 1 - Cammi, Garbi, Kretschmayer}
\headsep = 30pt                     % separaci\'on entre encabezado y comienzo del p\'arrafo

%\addtolength{\oddsidemargin}{-2cm}	% configuracion IDEAL!!!
%\addtolength{\textwidth}{4cm}
%\addtolength{\textheight}{2cm}

% macro 'todo' para To-Do's
\def\todo#1{\textcolor{red}{#1}}

% Macro 'borde' para un texto con borde
\newsavebox{\fmbox}
\newenvironment{borde}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}\\[10pt]}

%%%%%%%%%% FIN DEL PREAMBULO %%%%%%%%%%

\begin{document}

\materia{Algoritmos y Estucturas de datos III}
\submateria{Segundo Cuatrimestre de 2011}
\titulo{Trabajo Pr\'actico 1}
\subtitulo{Problema1: Campeonato de Tennis. \ \ \ \ \ \ \ \ \ \ \ \ \ \  Problema2: Pizza entre amigos. \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Problema3: Conjetura de Goldbach.}
\grupo{Grupo: `1'}
\integrante{Cammi, Mart\'in}{676/02}{martincammi@gmail.com}
\integrante{Garbi, Sebasti\'an}{179/05}{garbyseba@gmail.com}
\integrante{Kretschmayer, Daniel}{310/99}{daniak@gmail.com}

\maketitle

\thispagestyle{empty}

\tableofcontents

\newpage


\section{Ejecuci\'on del TP}
\label{sec:ejecucion}

	\subsection{Lenguaje utilizado}
		
		El lenguaje utilizado para el trabajo pr\'actico ha sido \emph{Java}, compilando con la versi\'on 1.5 de la Virtual Machine.
		
		Este trabajo se acompa�a con los fuentes de la soluci\'on que puede importarse en
		cualquier Eclipse IDE. 
		
	\subsection{Como ejecutar el TP}
	
	Desde cualquier Eclipse:
	\begin{itemize}
			\item{Seleccionar File $\Rightarrow$ Import.}
			\item{Sseleccionar General $\Rightarrow$ Existing Projects into Workspace $\Rightarrow$ Next.}
			\item{Seleccionar el directorio llamado Algo3Tp1.}
			\item{Finish.}
		\end{itemize}
	
	Desde la vista de \textbf{Package Explorer} bajo el paquete \textbf{src} aparecer\'an tres paquetes m�s y dentro de cada uno de ellos los siguientes archivos de java:
	
\begin{itemize}
	\item problema1
		\subitem Tennis.java
		\subitem TestTennis.java
	\item problema2
		\subitem Pizza.java
		\subitem TestPizza.java
	\item problema3
		\subitem Goldbach.java
		\subitem TestGoldbach.java
\end{itemize}

	Los archivos Tennis.java, Pizza.java y Goldbach.java contienen los algoritmos soluci\'on.
	El resto de los archivos que comienzan con \textbf{Test} son los tests asociados.

\newpage

% Conviene poner las secciones como diferentes archivos,
% sobre todo cuando se trabaja en equipo.
% Es m\'as f\'acil para sincronizar mediante control de versiones.
%\input{Introducci\'on}

% Problema1
\section{Problema1: Torneo}
\label{sec:problema3}
	\subsection{Introducci�n}
	
	  Debemos organizar un torneo con cierta cantidad de competidores que la llamaremos n. Si la cantidad de competidores es potencia de 2 o es par, el torneo debe terminar en n - 1 d�as. En cambio si n es impar, el torneo debe terminar en n d�as.
	  
		Para ello, implentaremos un algoritmo que utilice la t�cnica de divide y vencer�s. En cada llamada recursiva, el problema se divide la cantidad de jugadores por 2, se calcula los partidos que juegan entre s� de la primera mitad de ellos, y luego se combinan esos resultados para la otra mitad de los competidores.

	\subsection{Explicaci�n de la soluci�n}
	
	Para que un torneo se pueda armar, el n�mero de competidores debe ser mayor o igual a 2. En cambio, en caso de venir menor cantidad de jugadores, el algoritmo no crear� el torneo, ya que no tiene sentido realizarlo. 
	
	Para resolver el problema, utilizamos una matriz, para ir guardando la tabla de como van quedando los partidos entre cada competidor, y en que d�as �stos competir�n. La matriz tiene como filas la cantidad de jugadores del torneo, y como columnas la cantidad de d�as que demandar� este. En ambos casos, no utilizamos el �ndice 0, solo para facilitar la legibilidad del algoritmo.
	
	En cada llamada recursiva, el torneo se divide de a mitades, pero nosotros llamamos a recursi�n solo con la primera de ellas, y luego realizamos la etapa de combinaci�n de las subsoluciones, que termina calculando las competiciones para esta mitad de jugadores.
	
	Cuando la cantidad de competidores totales (o en cualquier llamada recursiva) es impar, lo que realiza el algoritmo es la de agregar un jugador "`ficticio"', y se gener� el torneo como si este fuese uno real. Para distinguirlo, utilizamos una funci�n que pone a ese jugador como el jugador 0. Luego, es la etapa de combinaci�n la que otorgar� a ese jugador el oponente en ese d�a, o caso contrario, implicar�a que el jugador ese tiene fecha libre ese d�a, por lo que la matriz final quedar� en 0.
	
	El caso base del algoritmo es cuando quedan 2 jugadores, que los hace competir en el d�a 1 entre si. 
	
	\subsection{Pseudo-c�digo}
	
\begin{algorithmic}

	%Para mas referencia ver http://en.wikibooks.org/wiki/LaTeX/Algorithms_and_Pseudocode
	\IF {cantJugadores == 2}
		\STATE	fixturePartidos[1][1] = 2;								\STATE	//caso base
		\STATE	fixturePartidos [2][1] = 1;	  						\STATE	//caso base
	\ELSE
			\IF {(cantJugadores mod 2)!=0}      					\STATE	//cantidad jugadores impar
				\STATE	torneo(cantJugadores+1);      					//recursion con jugador ficticio
				
				\STATE	colocarJugadorFicticio(cantJugadores);  //pone en cero a ese jugador
			\ELSE   \STATE	//si cantJugadores es par
				\STATE	mitadJugadores = cantJugadores / 2; 
				\STATE	torneo(mitadJugadores);      						// primero el cuadrante sup. izq.  
				
				\STATE	boolean esPar = (mitadJugadores mod 2) ==0;
				\STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar);
			\ENDIF
	 \ENDIF
	 
	 \STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar)
	 \IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores}
				\FOR {cada dia entre 1 y mitadJugadores-1}
					\STATE	fixturePartidos[jugador][dia] = fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores + 1 y cantJugadores}
				\FOR {cada dia entre 1 y mitadJugadores}
					\IF {fixturePartidos[jugador - mitadJugadores][dia] == 0}
						\STATE	fixturePartidos[jugador][dia]=0;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]= fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
			\STATE	sacarJugadorFicticio(mitadJugadores);
		\ENDIF
		
		
		\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1; y cantJugadores}
				\FOR {cada dia entre mitadJugadores y cantJugadores-1}
					\IF {jugador>dia}
						\STATE	fixturePartidos[jugador][dia]=jugador-dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre 1 y mitadJugadores}
				\FOR {cada dia entre mitadJugadores+1; y cantJugadores-1}
					\IF {jugador+dia <=cantJugadores}
						\STATE	fixturePartidos[jugador][dia] = jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = jugador + dia - mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF
	
		\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre 1 y mitadJugadores}
				\FOR {cada dia = mitadJugadores; dia <= cantJugadores-1; dia++}
					\IF {(jugador+dia)<=cantJugadores)}
						\STATE	fixturePartidos[jugador][dia]=jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]=jugador + dia - mitadJugadores;  //NO METER UN FICTICIO
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores}
				\FOR {cada dia = mitadJugadores+1; dia <= cantJugadores-1; dia++}
					\IF {jugador>dia}
						\STATE	fixturePartidos[jugador][dia] = jugador -dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF	
	
		\STATE	colocarJugadorFicticio(cantJugadores)
		\FOR {cada jugador entre 1 y cantJugadores}
			\FOR {cada dia entre 1 y cantJugadores}
				\IF {fixturePartidos[jugador][dia] == cantJugadores+1}
					\STATE	fixturePartidos[jugador][dia]= 0;
				\ENDIF
			\ENDFOR
		\ENDFOR
		
		sacarJugadorFicticio(mitadJugadores)
		\FOR {cada jugador entre 1 y mitadJugadores}
			\FOR {cada dia entre 1 y mitadJugadores}
				\IF {fixturePartidos[jugador][dia] == 0}
					\STATE	fixturePartidos[jugador][dia] = jugador + mitadJugadores; 
	 				\STATE	fixturePartidos[jugador+mitadJugadores][dia] = jugador;
				\ENDIF
			\ENDFOR
		\ENDFOR
	 
\end{algorithmic}	

\subsection{Complejidad}
	
\begin{algorithmic}

	\IF {cantJugadores == 2}
			\STATE	fixturePartidos[1][1] = 2;								//caso base
			\STATE	fixturePartidos [2][1] = 1;	  						//caso base
	\ELSE
			\IF {(cantJugadores mod 2)!=0}      					\STATE	//cantidad jugadores impar
				\STATE	torneo(cantJugadores+1);      					//recursion con jugador ficticio
				
				\STATE	colocarJugadorFicticio(cantJugadores);  //pone en cero a ese jugador
			\ELSE  \STATE		//si cantJugadores es par
			
				\STATE	mitadJugadores = cantJugadores / 2; 
				\STATE	torneo(mitadJugadores);      						// primero el cuadrante sup. izq.  
				
				\STATE	boolean esPar = (mitadJugadores mod 2) ==0;
				\STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar);
			\ENDIF
	 \ENDIF
	
	
	 \STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar)
	 \IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores}
				\FOR {cada dia entre 1 y mitadJugadores-1}
						\STATE	fixturePartidos[jugador][dia] = fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores + 1 y cantJugadores} 
				\FOR {cada dia entre 1 y mitadJugadores}
					\IF {fixturePartidos[jugador - mitadJugadores][dia] == 0} 
						\STATE	fixturePartidos[jugador][dia]=0;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]= fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
			\STATE	sacarJugadorFicticio(mitadJugadores);
		\ENDIF
		
		
		\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1; y cantJugadores} 
				\FOR {cada dia entre mitadJugadores y cantJugadores-1}
					\IF {jugador>dia} 
						\STATE	fixturePartidos[jugador][dia]=jugador-dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre 1 y mitadJugadores} 
				\FOR {cada dia entre mitadJugadores+1; y cantJugadores-1}
					\IF {jugador+dia <=cantJugadores} 
						\STATE	fixturePartidos[jugador][dia] = jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = jugador + dia - mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF
	
		\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre 1 y mitadJugadores} 
				\FOR {cada dia = mitadJugadores; dia <= cantJugadores-1; dia++}
					\IF {(jugador+dia)<=cantJugadores} 
						\STATE	fixturePartidos[jugador][dia]=jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]=jugador + dia - mitadJugadores;  //NO METER UN FICTICIO
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores} 
				\FOR {cada dia = mitadJugadores+1; dia <= cantJugadores-1; dia++}
					\IF {jugador>dia}
						\STATE	fixturePartidos[jugador][dia] = jugador -dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF	
	
		\STATE	colocarJugadorFicticio(cantJugadores)
		\FOR {cada jugador entre 1 y cantJugadores}  
			\FOR {cada dia entre 1 y cantJugadores}
				\IF {fixturePartidos[jugador][dia] == cantJugadores+1}
					\STATE	fixturePartidos[jugador][dia]= 0;
				\ENDIF
			\ENDFOR
		\ENDFOR
		
		\STATE	sacarJugadorFicticio(mitadJugadores)
		\FOR {cada jugador entre 1 y mitadJugadores} 
			\FOR {cada dia entre 1 y mitadJugadores}
				\IF {fixturePartidos[jugador][dia] == 0} 
					\STATE	fixturePartidos[jugador][dia] = jugador + mitadJugadores; 
	 				\STATE	fixturePartidos[jugador+mitadJugadores][dia] = jugador;
				\ENDIF
			\ENDFOR
		\ENDFOR
	
			
\end{algorithmic}	

	El costo del algoritmo es el orden que tarda la combinaci�n m�s el en dividir.
	
	Si analizamos la combinaci�n, veamos primero cual es el orden de cuadranteInferiorDerecho. Este recorre n / 2 jugadores, y para cada uno de ellos, chequea n / 2 dias para realizar los cruces en el torneo. El tiempo que se demora es de O ((n / 2) al cuadrado)
	
	El an�lisis para cuadranteInferiorIzquierdo, y cuadranteSuperiorDerecho es an�alogo el de cuadranteInferiorDerecho, pero al cuadranteInferiorIzquierdo hay que sumarle el tiempo que se demora en colocar el jugador ficticio, que es de O ((n / 2) al cuadrado), ya que nuevamente, recorre n / 2 jugadores y n/2 d�as. 
	Por lo que, si sumamos los 3 cuadrantes, m�s colocar el jugador ficticio, el tiempo que se demora es O(n al cuadrado). Notes� tambi�n, cuando la llamada recursiva tiene cantidad de jugadores impar, debe sacar al jugador ficticio, y el orden de este algoritmo tambi�n es de O (n al cuadrado).
	
	Como realizamos siempre la subdivisi�n en 2 veces, la cantidad de subdivisiones que realiza el algoritmo es log(n) veces.
	
	Por �ltimo, se debe dar el resultado (que se guarda en un archivo) de como quedo creado el torneo, por lo que se debe recorrer la matriz ya completa, e ir copiando en el archivo los resultados. Esa iteraci�n queda nuevamente O (n al cuadrado)
	
	Por lo que, el algoritmo se demora en total, O((n al cuadro)  * log(n)) + n al cuadrado))
	
	Ahora debemos calcular el algoritmo en funci�n del tama�o de entrada.
	
	T = log(n), ya que para representar un n�mero n, se necesitan log(n) bits.
	
	Entonces, n = 2 a la T.
	
	Entonces, la complejidad del algoritmo en funci�n del tama�o de entrada es de O( (log 2 a la T) * 2 a la T cuadrado + 2 a la T cuadrado).
	
	\subsection{Tests}
	
	Los test se han realizado hasta 5000 competidores de diferentes formas. En ellos hemos notado que obtuvimos un mejor caso en nuestro algoritmo, que es cuando la cantidad de jugadores es potencia de 2, y otro que pareciera ser el peor caso, cuando la cantidad de competidores es de la forma ((2 a la i) + 1), ya que tiene que agregar y sacar jugadores "`ficticios"' en una o m�s veces.
	
	\subsection{Gr�ficos}
	
	

	\subsection{Conclusiones}
\newpage

% Problema2
\section{Problema2: Pizza entre amigos}
\label{sec:problema2}
	\subsection{Introducci�n}
	Se quiere pedir una pizza extra gigante para un grupo de amigos. Cada uno de los amigos tiene su preferencia de elementos que quiere que est\'en en la pizza y elementos que preferir\'ia que no est\'en.
	Como no se puede satisfacer todas las preferencias de cada uno de los amigos, se pretende buscar una soluci\'on donde al menos una de las preferencias de cada amigo sea satisfecha, o responder que no es posible.
	\subsection{Explicaci�n de la soluci�n}
	Antes de explicar la soluci�n elegida, comentaremos algunas decisiones tomadas ad hoc:
	\begin{itemize}
		\item En la entrada puede llegar a venir en las preferencias de alguno de los comenzales un ingrediente repetido. Se descartaran las apariciones repetidas de ese ingrediete en caso que la decisi\'on tomada sobre el mismo sea la misma EJ +A+B+A lo tomaremos como +A+B.
		si alguna de las repeticiones tiene la desici\'on contr\'aria (EJ +A+B-A), entonces asumiremos que este comenzal est\'a satisfecho por defecto ya que cualquier decisi\'on tomada sobre el ingrediente en cuesti\'on lo satisfacer\'a.
		\item Otro caso ad hoc es cuando en la entrada viene una linea vacia (solo ';'), en este caso asumiremos que no existe una pizza que satisfaga al menos una preferencia de este comenzal ya que este no tiene preferencias.
	\end{itemize}
	Fuera de estos casos, asumimos que todos los comenzales tienen al menos una preferencia para la pizza.\\
	La idea del algoritmo es, usando backtracking, ir recorriendo un arbol de decisi�n donde la altura esta dada por la cantidad de ingredientes posibles + 1 y cada nivel i del arbol se corresponde al iesimo ingrediente cuyos subarboles son de las decisiones de poner o no ese ingrediente en la Pizza.\\
	En las hojas de este arbol estan todas las posibles combinaciones de pizza, si ya se revisaron todas las posibles combinaciones y ninguna cumpli� entonces no hay soluci�n para esas preferencias.
	En cada iteraci�n del algoritmo se van marcando los comenzales que fueron satisfechos con la desici�n tomada sobre el ingrediente actual, cuando se llega al �ltimo ingrediente si todos los comenzales estan marcados se devuelve esa pizza, si no se desmarcan y se prueba por otra rama del arbol y se repite el proceso.\\
	\textbf{Poda1:} Se puede ir chequeando a medida que se va armando la soluci�n parcial si ya todos los comenzales fueron marcados, si pas� esto se puede terminar antes ya que la soluci�n parcial es la misma que no poner el resto de los ingredientes.\\
	\textbf{Poda2:} En cada iteraci�n se chequean solo los comenzales que no hayan sido marcados ya en la soluci�n parcial actual, ya que los demas est�n satisfechos y seguiran estandolo cualquiera sea la desici�n que se tome sobre el resto de la pizza.\\
	\textbf{Poda3:} Antes de armar el arbol se revisa las preferencias de cada uno de los comenzales para ver cuales son los ingredientes que realmente importan ya que si nadie tiene preferencia (ya sea por que vaya o no en la pizza) sobre alg�n ingrediente est� de mas revisarlo.\\
	\textbf{Poda4:} Como estamos recorriendo el arbol de decisi�n desde la primera hasta la �ltima letra (ingrediente) en orden, podemos saber cuando un comenzal no va a poder ser satisfecho con la soluci�n parcial actual comparando el ingrediente actual con el "Mayor" en los que tiene una preferencia el comenzal.\\
	\textbf{Tip:} Vamos marcando los comenzales que fueron satisfechos junto con que ingrediente fueron satisfechos, por si hay que volver en el arbol se desmarcan solo esos y se prueba otra soluci�n\\
	\subsection{Pseudo-c�digo}
	\begin{algorithmic}
	%Para mas referencia ver http://en.wikibooks.org/wiki/LaTeX/Algorithms_and_Pseudocode
	\STATE i $\gets$ PrimerIngredienteImportante
	\STATE backtrack:
	\STATE poner i en la pizza
	\STATE marcar comenzales satisfechos
	\IF {no hay mas comenzales insatisfechos}
		\STATE \textbf{return} pizza
		\STATE terminar
	\ELSE
		\IF{quedan ingredientes sin mirar}
			\STATE i $\gets$ siguienteIngrediente
			\STATE llamar backtrack
			\STATE i $\gets$ anteriorIngrediente
		\ENDIF
		\STATE desmarcar comenzales satisfechos
		\STATE sacar i de la pizza
		\STATE marcar comenzales satisfechos
		\IF {no hay mas comenzales insatisfechos}
			\STATE \textbf{return} pizza
			\STATE terminar
		\ELSE
			\IF{quedan ingredientes sin mirar}
				\STATE i $\gets$ siguienteIngrediente
				\STATE llamar backtrack
				\STATE i $\gets$ anteriorIngrediente
			\ENDIF
		\ENDIF
	\ENDIF
	\IF{i == PrimerIngredienteImportante}
		\STATE terminar sin soluci�n
	\ELSE
		\STATE volver a donde se llam�
	\ENDIF
	\end{algorithmic}	
	\subsection{Complejidad}
	
	\subsection{Tests}
	\subsection{Gr�ficos}
	\subsection{Conclusiones}
\newpage


% Problema3
\section{Problema3: Conjetura de Goldbach.}
\label{sec:problema3}
	\subsection{Introducci\'on}
	
		En matem\'atica una conjetura es una afirmaci\'on que no ha sido demostrada, pero basado en pruebas emp\'iricas parecer\'ia ser cierta. En este contexto la Conjetura de Goldbach o Conjetura fuerte de Goldbach intenta expresar una verdad una relaci\'on entre pares y primos que no ha sido a\'un verificada en su totalidad, dicha conjetura enuncia que:\\
		
		Todo n\'umero par mayor a dos puede ser escrito como suma de dos n\'umeros primos.\\
		
	En el presente trabajo implentaremos un algoritmo que, basado en la Conjetura de Goldbach y dado un n\'umero par mayor a dos, retorne dos primos que sumados obtengan dicho n\'umero.
	
	Utilizaremos la t\'ecnica de backtraking para generar posibles soluciones e ir al mismo 
tiempo realizando podas para no recorrer las que no los sean.

	Se analizar\'a tambi\'en la complejidad del algoritmo en base al tama�o de la entrada utilizando modelos de complejidad.
		
	Finalmente se realizar\'an gr\'aficas y analizar\'an peores casos, casos promedios y posibles casos patol\'ogicos.
	
	\subsection{Explicaci\'on de la soluci\'on}
	
	Como precondici\'on para el algoritmo el n\'umero n ingresado deber\'a ser par. A continuaci\'on
	el algoritmo ir\'a generando pares de n\'umeros que sumen n y que sean candidatos a soluci\'on del siguiente modo:\\
	
	1 + (n-1),
	2 + (n-2),
	...
	(n/2) + (n/2),
	...
	(n-2) + 2,
	(n-1) + 1\\
	
	\textbf{Poda1:} Lo primero que notamos es que al llegar a la mitad de pares generados la siguiente mitad ser\'a
	similar a la anterior ya que ser\'an los mismos sumandos pero invertidos con respecto a la suma.
	Entonces con verificar que sumandos son primos en la primera mitad basta para tambi\'en cubir los casos de la segunda mitad.
	
	La primera poda entonces es solo recorrer la primer mitad:\\
	
	1 + (n-1),
	2 + (n-2),
	...
	(n/2) + (n/2)\\
	
	\textbf{Poda2:} Tambi\'en puede verse que el n\'umero 1 no es de por si primo as\'i que cualquier suma en que participe no ser\'a una soluci\'on v\'alida. Podamos entonces la soluci\'on del 1.\\
	
	2 + (n-2),
	...
	(n/2) + (n/2)\\
	
	\textbf{Poda3:} Del mismo modo, tambi\'en podemos observar que cualquier n\'umero par, salvo el 2 no ser\'a primo ya que al ser par ser\'a divisible por 2. Excluimos entonces todas las sumas con pares en ellas salvo la que contenga al 2.\\
	
	2 + (n-2),
	3 + (n-3)
	...
	2m+1 (n-(2m+1))
	...
	(n/2)-1 + (n/2)+1\\
	
	\textbf{Poda4:} El caso del 2 podr\'iamos tratarlo a parte ya que la \'unica suma en la que participa es en la del 4 donde 4 = 2 + 2. No existe otra suma en la que el primo 2 aparezca ya que cualquier par que tenga como un sumando al 2 deberia tener como segundo sumando a otro n\'umero par y adem\'as primo y el \'unico que cumple esa condici\'on es el 2 caso que acabamos de excluir.\\
		
	3 + (n-3)
	...
	2m+1 (n-(2m+1))
	...
	(n/2)-1 + (n/2)+1\\	
	
	De esta forma generamos pares de n\'umeros que sumados dan el par inicial y que han sido previamente filtrados por las podas mencionadas. A continuaci\'on se verificar\'a si alguno de ellos es soluci\'on. La definici\'on de soluci\'on en este problema es para cada par si ambos n\'umeros son primos.
	
	Para el c\'alculo de si un n\'umero es primo verificaremos si el \'unico divisor positivo adem\'as del uno es si mismo, para ello se dividir\'a por todos los menores.
	
		\textbf{Poda5:} Un optimizaci\'on que se ha tenido en cuenta es verificar los divisores solo hasta la raiz cuadrada.
		
		\textbf{Poda6:} Tambi\'en, si al recorrer un par de sumandos notamos que ambos son iguales, verificaremos si es primo s\'olo uno de ellos, ya que es an\'alogo hacerlo con el par id\'entico.
		ej: Si el n considerado es 10 y se est\'a evaluando el par 5 + 5, solo verificaremos si 5 es primo una sola vez.
	
	Cabe aclarar que para optimizar el algoritmo la generaci\'on de candidatos y la verificaci\'on de soluci\'on se realizar\'an simult\'aneamente. No generaremos todas las soluciones y luego las verificaremos una a una, sino que verificaremos una a una a medida que las vayamos generando.
	
	\subsection{Pseudo-c\'odigo}

\begin{algorithmic}

	%Para mas referencia ver http://en.wikibooks.org/wiki/LaTeX/Algorithms_and_Pseudocode
	\FOR {cada n1,n2 candidatos podados}
        \IF {esPrimo(n1) y esPrimo(n2)}
            \STATE retornar n1, n2
        \ENDIF
	\ENDFOR

\end{algorithmic}	

	\subsection{Modelo elegido}
	
		Para el c\'alculo del orden utilizaremos primeramente el modelo \emph{Uniforme} ya que las operaciones b\'asicas que posee el algoritmo no son significativas ni parecen influir tanto como las iteraciones principales.
		
		De todos modos realizaremos tambi\'en un an\'alisis con el modelo \emph{logar\'itmico} para observar que si alguna operaci\'on b\'asica en particular prepondera sobre otras o puede afectar el algoritmo para alguna entrada en particular
		
		Analizaremos tambi\'en los peores casos y compararemos ambas gr\'aficas con ambos modelos.

\newpage		

\subsection{Complejidad temporal}
	
	La siguiente complejidad se calcula en base al modelo \emph{Uniforme}. 
	
	A continuaci\'on se describe el algoritmo donde se ha asignado a cada paso relevante las complejidades correpondientes:

%RESTAURAR	Aca antes decia verbatim ver si esto anda
%\begin{alltt}
	Paso1:    Para cada n1,n2 candidatos O(n/4)
	Paso2:       Si esPrimo(n1) y esPrimo(n2) entonces 	O($\sqrt{n1}$) + O($\sqrt{n2}$)
	Paso3:         retornar n1, n2
	Paso4:       Fin Si
	Paso5:    Fin Para 
%\end{alltt}	

		
	\textbf{Paso1:} Comenzaremos recorriendo de todos los posibles candidatos solo la mitad, ya que la otra mitad corresponde a soluciones an\'alogas (Poda1) recorreremos entonces n/2 pares de cantidatos. De esa mitad solo interesar\'an los pares pares ya que si alguno no lo fuese ser\'ia primo (el caso de 4 se tratar\'a aparte) de este modo de los n/2 pares recorreremos solo la mitad es decir n/4. La complejidad de este ciclo es de O(n/4).\\
	
	\textbf{Paso2:} Este paso basar\'a su complejidad en la complejidad de \emph{esPrimo}.
esPrimo dado un entero positivo n recorre todos los valores menores verificando si alguno
es divisor. Una optimizaci\'on ha sido recorrer hasta valores hasta la raiz de este modo la complejidad de esPrimo es de $O(\sqrt{n})$ que de todos modos diremos que es acotable por O(n).\\

De esta forma calculamos el costo del algoritmo recorriendo solo los pares impares hasta la mitad. Para ayudar a calcular este orden definamos entonces la funci\'on\\ verificarSoluci\'on(i,n) como esPrimo(i) $\wedge$ esPrimo(n-i);\\

	\begin{center}
	$\displaystyle\sum\limits_{i=1}^{n/4}  verificarSolucion(2 \cdot i+1,n)$.\\
	\end{center}
	
	\begin{center}
	$\displaystyle\sum\limits_{i=1}^{n/4} esPrimo(2 \cdot i+1)+esPrimo(n-(2 \cdot i+1))$.\\
	\end{center}
	
	\begin{center}
	Como esPrimo(n) es O($\sqrt(n)$) $\subset$ O(n) es acotable por O(n).\\
	\end{center}

	\begin{center}
	$\displaystyle\sum\limits_{i=1}^{n/4} (2 \cdot i+1) + n - (2 \cdot i+1)$.\\
	\end{center}
	
	\begin{center}
	Simplificando los t\'erminos $(2 \cdot i+1) $:\\
	\end{center}

	\begin{center}
  $\displaystyle\sum\limits_{i=1}^{n/4} n$\\
	\end{center}
	
	\begin{center}
	$\frac{n}{4} \cdot n = {\frac{n^2}{4}}$ es $O(n^2)$.\\ 
	\end{center}
	
	Ahora bien, para describir la complejidad en funci\'on del tama�o de la entrada debemos tener en cuenta la representaci\'on del n\'umero de entrada n en la computadora.
	Un n\'umero n ser\'a representado como $\log n$ bits.
	
	Definimos entonces el tama�o de entrada como:\\
	
	\begin{center}
	$T = \log n$\\
	\end{center}
	
	Si respejamos n para describir la complejidad en funci\'on de T:
	
	\begin{center}
	$2^T = n$\\
	\end{center}
	
	Como la complejidad de nuestro algoritmo es de $O(n^2)$ aplicamos cuadrado a ambos lados para ver la complejidad en T:
	
	\begin{center}
	$(2^T)^2 = n^2$\\
	\end{center}
	
	\begin{center}
	$(2^{2T}) = n^2$\\
	\end{center}
	
	La complejidad temporal en base a T es exponencial del orden de $O(2^{2T})$
	
	\subsection{Tests}
	\subsection{Gr\'aficos}
	
	\begin{center}
	%RESTAURAR
	%\includegraphics{ComplejidadGoldbachUniforme.jpg}
	\end{center}
	
	\subsection{Conclusiones}
\newpage


\end{document}
