\documentclass[11pt, a4paper, spanish]{article}

\usepackage{alltt}

%%%%%%%%%% COMIENZO DEL PREAMBULO %%%%%%%%%%

%Info sobre este documento
\author{Mart\'n Cammi}
\title{Trabajo Pr\'actico de Algoritmos y Estucturas de datos III}

%\usepackage{infostyle}                                                  % provee un look & feel similar a un documento Word
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}  % m\'argenes
\usepackage[ansinew]{inputenc}                                           % permite que los acentos del estilo \'a\'e\'i\'o\'u salgan joya
\usepackage[spanish, activeacute]{babel}                                 % idioma espaniol, acentos f\'aciles y deletreo de palabras
\usepackage{indentfirst}                                                 % permite indentar un parrafo a mano
\usepackage{caratula}                                                    % incluye caratula est\'andar
\usepackage{graphicx}                                                    % permite insertar gr\'aficos
\usepackage{color}                                                       % permite el uso de colores en el documento
\usepackage[pdfcreator={TexLive!, LaTeX2e con TeXnicCenter},
			pdfauthor={Grupo: "1"},
			pdftitle={Algoritmos III - Trabajo Pr\'actico 1},
			pdfsubject={Trabajo Pr\'actico 1},
			pdfkeywords={Tennis, Pizza, Goldbach},
			pdfstartview=FitH,            % Fits the width of the page to the window
			bookmarksnumbered,            % los bookmarks numerados se ven mejor...
			colorlinks,                   % links con bellos colores
			linkcolor=magenta]            % permite cambiar el color de los links
			{hyperref}                    % Permite jugar con algunas cosas que aparecer\'an en el PDF final

%RESTAURAR
\usepackage{algorithm}							% Permite tabular un codigo
\usepackage{algorithmic}
%\input{spanishAlgorithmic} % mi archivo de traducci\'on			

%\selectlanguage{spanish}

%\selectlanguage{spanish}
\linespread{1.3}                    % interlineado equivalente al 1.5 l\'ineas de Word...
\pagestyle{myheadings}              %encabezado personalizable con \markboth{}{}
\markboth{}{Algoritmos III  - Trabajo Pr\'actico 1 - Cammi, Garbi, Kretschmayer}
\headsep = 30pt                     % separaci\'on entre encabezado y comienzo del p\'arrafo

%\addtolength{\oddsidemargin}{-2cm}	% configuracion IDEAL!!!
%\addtolength{\textwidth}{4cm}
%\addtolength{\textheight}{2cm}

% macro 'todo' para To-Do's
\def\todo#1{\textcolor{red}{#1}}

% Macro 'borde' para un texto con borde
\newsavebox{\fmbox}
\newenvironment{borde}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}\\[10pt]}

%%%%%%%%%% FIN DEL PREAMBULO %%%%%%%%%%

\begin{document}

\materia{Algoritmos y Estucturas de datos III}
\submateria{Segundo Cuatrimestre de 2011}
\titulo{Trabajo Pr\'actico 1}
\subtitulo{Problema1: Campeonato de Tennis. \ \ \ \ \ \ \ \ \ \ \ \ \ \  Problema2: Pizza entre amigos. \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Problema3: Conjetura de Goldbach.}
\grupo{Grupo: `1'}
\integrante{Cammi, Mart\'in}{676/02}{martincammi@gmail.com}
\integrante{Garbi, Sebasti\'an}{179/05}{garbyseba@gmail.com}
\integrante{Kretschmayer, Daniel}{310/99}{daniak@gmail.com}

\maketitle

\thispagestyle{empty}

\tableofcontents

\newpage


\section{Ejecuci\'on del TP}
\label{sec:ejecucion}

	\subsection{Lenguaje utilizado}
		
		El lenguaje utilizado para el trabajo pr\'actico ha sido \emph{Java}, compilando con la versi\'on 1.5 de la Virtual Machine.
		
		El trabajo se acompa\~{n}a con los fuentes de la soluci\'on que puede importarse en IDE de Eclipse.

		
	\subsection{Como ejecutar el TP}
	
	\textbf{\underline{Desde l\'inea de comandos}}
	\begin{itemize}
			\item{TODO Complete this}
	\end{itemize}

	\textbf{\underline{Desde el Eclipse}}
	\begin{itemize}
			\item{Seleccionar File $\Rightarrow$ Import.}
			\item{Seleccionar General $\Rightarrow$ Existing Projects into Workspace $\Rightarrow$ Next.}
			\item{Seleccionar el directorio llamado Algo3Tp1.}
			\item{Finish.}
	\end{itemize}
	
	Desde la vista de \textbf{Package Explorer} bajo el paquete \textbf{src} aparecer\'an tres paquetes más y dentro de cada uno de ellos los siguientes archivos de java:
	
TODO colocar grafico del eclipse
\begin{itemize}
	\item problema1
		\subitem Torneo.java
	\item problema2
		\subitem Pizza.java
	\item problema3
		\subitem Goldbach.java
\end{itemize}

\newpage

% Conviene poner las secciones como diferentes archivos,
% sobre todo cuando se trabaja en equipo.
% Es m\'as f\'acil para sincronizar mediante control de versiones.
%\input{Introducci\'on}

% Problema1
\section{Problema1: Torneo}
\label{sec:problema3}
	\subsection{Introducci\'on}
	
	  Debemos organizar un torneo con cierta cantidad de competidores que la llamaremos n. Si la cantidad de competidores es potencia de 2 o es par, el torneo debe terminar en n - 1 d\'ias. En cambio si n es impar, el torneo debe terminar en n d\'ias.\\
	  
		Para ello, implentaremos un algoritmo que utilice la t\'ecnica de divide y vencer\'as. En cada llamada recursiva, el problema se divide la cantidad de jugadores por 2, se calcula los partidos que juegan entre s\'i de la primera mitad de ellos, y luego se combinan esos resultados para la otra mitad de los competidores.

	\subsection{Explicaci\'on de la soluci\'on}
	
	Para que un torneo se pueda armar, el n\'umero de competidores debe ser mayor o igual a 2. En cambio, en caso de venir menor cantidad de jugadores, el algoritmo no crear\'a el torneo, ya que no tiene sentido realizarlo. \\
	
	Para resolver el problema, utilizamos una matriz, para ir guardando la tabla de como van quedando los partidos entre cada competidor, y en que dias \'estos competir\'an. La matriz tiene como filas la cantidad de jugadores del torneo, y como columnas la cantidad de dias que demandar\'a este. En ambos casos, no utilizamos el \'indice 0, solo para facilitar la legibilidad del algoritmo.\\
	
	En cada llamada recursiva, el torneo se divide de a mitades, pero nosotros llamamos a recursi\'on solo con la primera de ellas, y luego realizamos la etapa de combinaci\'on de las subsoluciones, que termina calculando las competiciones para esta mitad de jugadores.\\
	
	Cuando la cantidad de competidores totales (o en cualquier llamada recursiva) es impar, lo que realiza el algoritmo es la de agregar un jugador "`ficticio"', y se gener\'o el torneo como si este fuese uno real. Para distinguirlo, utilizamos una funci\'on que pone a ese jugador como el jugador 0. Luego, es la etapa de combinaci\'on la que otorgar\'o a ese jugador el oponente en ese d\'ia, o caso contrario, implicar\'ia que el jugador ese tiene fecha libre ese d\'ia, por lo que la matriz final quedar\'a en 0.\\
	
	El caso base del algoritmo es cuando quedan 2 jugadores, que los hace competir en el d\'ia 1 entre si. 

\newpage
	
\subsection{Pseudo-c\'odigo}
	
\begin{algorithmic}

	%Para mas referencia ver http://en.wikibooks.org/wiki/LaTeX/Algorithms_and_Pseudocode
	\IF {cantJugadores == 2}
		\STATE	fixturePartidos[1][1] = 2;								\STATE	//caso base
		\STATE	fixturePartidos [2][1] = 1;	  						\STATE	//caso base
	\ELSE
			\IF {(cantJugadores mod 2)!=0}      					\STATE	//cantidad jugadores impar
				\STATE	torneo(cantJugadores+1);      					//recursion con jugador ficticio
				
				\STATE	colocarJugadorFicticio(cantJugadores);  //pone en cero a ese jugador
			\ELSE   \STATE	//si cantJugadores es par
				\STATE	mitadJugadores = cantJugadores / 2; 
				\STATE	torneo(mitadJugadores);      						// primero el cuadrante sup. izq.  
				
				\STATE	boolean esPar = (mitadJugadores mod 2) ==0;
				\STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar);
			\ENDIF
	 \ENDIF
	 
	 \STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar)
	 \IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores}
				\FOR {cada dia entre 1 y mitadJugadores-1}
					\STATE	fixturePartidos[jugador][dia] = fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores + 1 y cantJugadores}
				\FOR {cada dia entre 1 y mitadJugadores}
					\IF {fixturePartidos[jugador - mitadJugadores][dia] == 0}
						\STATE	fixturePartidos[jugador][dia]=0;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]= fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
			\STATE	sacarJugadorFicticio(mitadJugadores);
		\ENDIF
		
		
		\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1; y cantJugadores}
				\FOR {cada dia entre mitadJugadores y cantJugadores-1}
					\IF {jugador>dia}
						\STATE	fixturePartidos[jugador][dia]=jugador-dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre 1 y mitadJugadores}
				\FOR {cada dia entre mitadJugadores+1; y cantJugadores-1}
					\IF {jugador+dia <=cantJugadores}
						\STATE	fixturePartidos[jugador][dia] = jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = jugador + dia - mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF
	
		\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre 1 y mitadJugadores}
				\FOR {cada dia = mitadJugadores; dia <= cantJugadores-1; dia++}
					\IF {(jugador+dia)<=cantJugadores)}
						\STATE	fixturePartidos[jugador][dia]=jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]=jugador + dia - mitadJugadores;  //NO METER UN FICTICIO
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores}
				\FOR {cada dia = mitadJugadores+1; dia <= cantJugadores-1; dia++}
					\IF {jugador>dia}
						\STATE	fixturePartidos[jugador][dia] = jugador -dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF	
	
		\STATE	colocarJugadorFicticio(cantJugadores)
		\FOR {cada jugador entre 1 y cantJugadores}
			\FOR {cada dia entre 1 y cantJugadores}
				\IF {fixturePartidos[jugador][dia] == cantJugadores+1}
					\STATE	fixturePartidos[jugador][dia]= 0;
				\ENDIF
			\ENDFOR
		\ENDFOR
		
		sacarJugadorFicticio(mitadJugadores)
		\FOR {cada jugador entre 1 y mitadJugadores}
			\FOR {cada dia entre 1 y mitadJugadores}
				\IF {fixturePartidos[jugador][dia] == 0}
					\STATE	fixturePartidos[jugador][dia] = jugador + mitadJugadores; 
	 				\STATE	fixturePartidos[jugador+mitadJugadores][dia] = jugador;
				\ENDIF
			\ENDFOR
		\ENDFOR
	 
\end{algorithmic}	

\subsection{Complejidad}
	
\begin{algorithmic}

	\IF {cantJugadores == 2}
			\STATE	fixturePartidos[1][1] = 2;								//caso base
			\STATE	fixturePartidos [2][1] = 1;	  						//caso base
	\ELSE
			\IF {(cantJugadores mod 2)!=0}      					\STATE	//cantidad jugadores impar
				\STATE	torneo(cantJugadores+1);      					//recursion con jugador ficticio
				
				\STATE	colocarJugadorFicticio(cantJugadores);  //pone en cero a ese jugador
			\ELSE  \STATE		//si cantJugadores es par
			
				\STATE	mitadJugadores = cantJugadores / 2; 
				\STATE	torneo(mitadJugadores);      						// primero el cuadrante sup. izq.  
				
				\STATE	boolean esPar = (mitadJugadores mod 2) ==0;
				\STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar);
				\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar);
			\ENDIF
	 \ENDIF
	
	
	 \STATE	cuadranteInferiorIzquierdo(mitadJugadores, cantJugadores, esPar)
	 \IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores}
				\FOR {cada dia entre 1 y mitadJugadores-1}
						\STATE	fixturePartidos[jugador][dia] = fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores + 1 y cantJugadores} 
				\FOR {cada dia entre 1 y mitadJugadores}
					\IF {fixturePartidos[jugador - mitadJugadores][dia] == 0} 
						\STATE	fixturePartidos[jugador][dia]=0;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]= fixturePartidos[jugador-mitadJugadores][dia] + mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
			\STATE	sacarJugadorFicticio(mitadJugadores);
		\ENDIF
		
		
		\STATE	cuadranteInferiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre mitadJugadores+1; y cantJugadores} 
				\FOR {cada dia entre mitadJugadores y cantJugadores-1}
					\IF {jugador>dia} 
						\STATE	fixturePartidos[jugador][dia]=jugador-dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre 1 y mitadJugadores} 
				\FOR {cada dia entre mitadJugadores+1; y cantJugadores-1}
					\IF {jugador+dia <=cantJugadores} 
						\STATE	fixturePartidos[jugador][dia] = jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = jugador + dia - mitadJugadores;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF
	
		\STATE	cuadranteSuperiorDerecho(mitadJugadores, cantJugadores, esPar)
		\IF {esPar}
			\FOR {cada jugador entre 1 y mitadJugadores} 
				\FOR {cada dia = mitadJugadores; dia <= cantJugadores-1; dia++}
					\IF {(jugador+dia)<=cantJugadores} 
						\STATE	fixturePartidos[jugador][dia]=jugador+dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia]=jugador + dia - mitadJugadores;  //NO METER UN FICTICIO
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ELSE
			\FOR {cada jugador entre mitadJugadores+1 y cantJugadores} 
				\FOR {cada dia = mitadJugadores+1; dia <= cantJugadores-1; dia++}
					\IF {jugador>dia}
						\STATE	fixturePartidos[jugador][dia] = jugador -dia;
					\ELSE
						\STATE	fixturePartidos[jugador][dia] = (jugador + mitadJugadores)-dia;
					\ENDIF
				\ENDFOR
			\ENDFOR
		\ENDIF	
	
		\STATE	colocarJugadorFicticio(cantJugadores)
		\FOR {cada jugador entre 1 y cantJugadores}  
			\FOR {cada dia entre 1 y cantJugadores}
				\IF {fixturePartidos[jugador][dia] == cantJugadores+1}
					\STATE	fixturePartidos[jugador][dia]= 0;
				\ENDIF
			\ENDFOR
		\ENDFOR
		
		\STATE	sacarJugadorFicticio(mitadJugadores)
		\FOR {cada jugador entre 1 y mitadJugadores} 
			\FOR {cada dia entre 1 y mitadJugadores}
				\IF {fixturePartidos[jugador][dia] == 0} 
					\STATE	fixturePartidos[jugador][dia] = jugador + mitadJugadores; 
	 				\STATE	fixturePartidos[jugador+mitadJugadores][dia] = jugador;
				\ENDIF
			\ENDFOR
		\ENDFOR
	
			
\end{algorithmic}	

\newpage

	El costo del algoritmo es el orden que tarda la combinaci\'on m\'as el en dividir.
	
	Si analizamos la combinaci\'on, veamos primero cual es el orden de cuadranteInferiorDerecho. Este recorre n / 2 jugadores, y para cada uno de ellos, chequea n / 2 dias para realizar los cruces en el torneo. El tiempo que se demora es de O ((n / 2) al cuadrado)\\
	
	El an\'alisis para cuadranteInferiorIzquierdo, y cuadranteSuperiorDerecho es an\'aalogo el de cuadranteInferiorDerecho, pero al cuadranteInferiorIzquierdo hay que sumarle el tiempo que se demora en colocar el jugador ficticio, que es de O ((n / 2) al cuadrado), ya que nuevamente, recorre n / 2 jugadores y n/2 d\'ias. 

	Por lo que, si sumamos los 3 cuadrantes, m\'as colocar el jugador ficticio, el tiempo que se demora es O(n al cuadrado). Notes\'e tambi\'en, cuando la llamada recursiva tiene cantidad de jugadores impar, debe sacar al jugador ficticio, y el orden de este algoritmo tambi\'en es de O (n al cuadrado).\\
	
	Como realizamos siempre la subdivisi\'on en 2 veces, la cantidad de subdivisiones que realiza el algoritmo es log(n) veces.
	
	Por \'ultimo, se debe dar el resultado (que se guarda en un archivo) de como quedo creado el torneo, por lo que se debe recorrer la matriz ya completa, e ir copiando en el archivo los resultados. Esa iteraci\'on queda nuevamente O (n al cuadrado) por lo que, el algoritmo se demora en total, O((n al cuadro)  * log(n)) + n al cuadrado))\\
	
	Ahora debemos calcular el algoritmo en funci\'on del tama\~{n}o de entrada.
	
	T = log(n), ya que para representar un n\'umero n, se necesitan log(n) bits.
	
	Entonces, n = 2 a la T.
	
	Entonces, la complejidad del algoritmo en funci\'on del tama\~{n}o de entrada es de O( (log 2 a la T) * 2 a la T cuadrado + 2 a la T cuadrado).
	

\newpage

\subsection{Tests}
	
	Los test se han realizado hasta 5000 competidores de diferentes formas. En ellos hemos notado que obtuvimos un mejor caso en nuestro algoritmo, que es cuando la cantidad de jugadores es potencia de 2, y otro que pareciera ser el peor caso, cuando la cantidad de competidores es de la forma ((2 a la i) + 1), ya que tiene que agregar y sacar jugadores "`ficticios"' en una o m\'as veces.
	
\subsection{Gr\'aficos}
	
	

\subsection{Conclusiones}
\newpage

% Problema2
\section{Problema2: Pizza entre amigos}
\label{sec:problema2}
	\subsection{Introducci\'on}
	Se quiere pedir una pizza extra gigante para un grupo de amigos. Cada uno de los amigos tiene su preferencia de elementos que quiere que est\'en en la pizza y elementos que preferir\'ia que no est\'en.
	Como no se puede satisfacer todas las preferencias de cada uno de los amigos, se pretende buscar una soluci\'on donde al menos una de las preferencias de cada amigo sea satisfecha, o responder que no es posible.
	\subsection{Explicaci\'on de la soluci\'on}
	Antes de explicar la soluci\'on elegida, comentaremos algunas decisiones tomadas ad hoc:
	\begin{itemize}
		\item En la entrada puede llegar a venir en las preferencias de alguno de los comenzales un ingrediente repetido. Se descartaran las apariciones repetidas de ese ingrediete en caso que la decisi\'on tomada sobre el mismo sea la misma EJ +A+B+A lo tomaremos como +A+B.
		si alguna de las repeticiones tiene la desici\'on contr\'aria (EJ +A+B-A), entonces asumiremos que este comenzal est\'a satisfecho por defecto ya que cualquier decisi\'on tomada sobre el ingrediente en cuesti\'on lo satisfacer\'a.
		\item Otro caso ad hoc es cuando en la entrada viene una linea vacia (solo ';'), en este caso asumiremos que no existe una pizza que satisfaga al menos una preferencia de este comenzal ya que este no tiene preferencias.
	\end{itemize}

Fuera de estos casos, asumimos que todos los comenzales tienen al menos una preferencia para la pizza.\\
	La idea del algoritmo es, usando backtracking, ir recorriendo un arbol de decisi\'on donde la altura esta dada por la cantidad de ingredientes posibles + 1 y cada nivel i del arbol se corresponde al iesimo ingrediente cuyos subarboles son de las decisiones de poner o no ese ingrediente en la Pizza.\\
	
En las hojas de este arbol estan todas las posibles combinaciones de pizza, si ya se revisaron todas las posibles combinaciones y ninguna cumpli\'o entonces no hay soluci\'on para esas preferencias.
	
En cada iteraci\'on del algoritmo se van marcando los comenzales que fueron satisfechos con la desici\'on tomada sobre el ingrediente actual, cuando se llega al último ingrediente si todos los comenzales estan marcados se devuelve esa pizza, si no se desmarcan y se prueba por otra rama del arbol y se repite el proceso.\\

\textbf{Poda1:} Se puede ir chequeando a medida que se va armando la soluci\'on parcial si ya todos los comenzales fueron marcados, si pas\'o esto se puede terminar antes ya que la soluci\'on parcial es la misma que no poner el resto de los ingredientes.\\

\textbf{Poda2:} En cada iteraci\'on se chequean solo los comenzales que no hayan sido marcados ya en la soluci\'on parcial actual, ya que los demas est\'an satisfechos y seguiran estandolo cualquiera sea la desici\'on que se tome sobre el resto de la pizza.\\

\textbf{Poda3:} Antes de armar el arbol se revisa las preferencias de cada uno de los comenzales para ver cuales son los ingredientes que realmente importan ya que si nadie tiene preferencia (ya sea por que vaya o no en la pizza) sobre algún ingrediente est\'a de mas revisarlo.\\

\textbf{Poda4:} Como estamos recorriendo el arbol de decisi\'on desde la primera hasta la última letra (ingrediente) en orden, podemos saber cuando un comenzal no va a poder ser satisfecho con la soluci\'on parcial actual comparando el ingrediente actual con el "Mayor" en los que tiene una preferencia el comenzal.\\

\textbf{Tip:} Vamos marcando los comenzales que fueron satisfechos junto con que ingrediente fueron satisfechos, por si hay que volver en el arbol se desmarcan solo esos y se prueba otra soluci\'on\\
	\subsection{Pseudo-c\'odigo}
	\begin{algorithm}                      % enter the algorithm environment
	\caption{Pizza}          	       % give the algorithm a caption
	\label{alg1}  
	\begin{algorithmic}
	%Para mas referencia ver http://en.wikibooks.org/wiki/LaTeX/Algorithms_and_Pseudocode
	\STATE i $\gets$ PrimerIngredienteImportante
	\STATE pizza $\gets$ pizzaVacia
	\STATE ponerEnLaPizza $\gets$ \TRUE
	\IF{ backtrack(i, ponerEnLaPizza) }
		\RETURN pizza
		\STATE terminar
	\ELSE
		\IF{ backtrack(i, !ponerEnLaPizza)}
			\RETURN pizza
			\STATE terminar
		\ELSE
			\STATE terminar sin soluci\'on
		\ENDIF
	\ENDIF
	\end{algorithmic}
	\end{algorithm}
	%%fijate que estas son dos funciones distintas para que queden separadas por un enter por lo menos 
	\begin{algorithmic}
	\STATE backtrack(i, ponerEnLaPizza)
	\IF{ponerEnLaPizza == \TRUE}
		\STATE poner i en la pizza
	\ENDIF
	\STATE marcar comenzales satisfechos 
	\IF {no hay mas comenzales insatisfechos} 
		\RETURN \TRUE
	\ELSE
		\IF{quedan ingredientes sin mirar} 
			\STATE i $\gets$ siguienteIngrediente 
			\IF{ backtrack(i, ponerEnLaPizza)}
				\RETURN \TRUE
			\ELSE
				\IF{backtrack(i,\TRUE)}
					\RETURN \TRUE
				\ELSE
					\STATE i $\gets$ anteriorIngrediente
				\ENDIF
			\ENDIF
		\ENDIF
		\STATE desmarcar comenzales satisfechos
		\IF{ponerEnLaPizza == \TRUE}
			\STATE sacar i de la pizza
		\ENDIF
		\RETURN \FALSE
	\ENDIF
	\end{algorithmic}	
	\subsection{Modelo Elejido}
	Para calcular la complejidad de este algoritmo utilizaremos el modelo $Uniforme$, ya que por mas que la cantidad de datos de la entrada crezca, las operaciones sobre cada uno de ellos es constante y podemos asumirla en $O(1)$
	\subsection{Complejidad}
	
	$n$ = Cantidad de Ingredientes\\
	$m$ = Cantidad de Comezales
	Preguntar si un comenzal prefiere un ingrediente es $O(1)$\\
	Preguntar si quedan comenzales insatisfechos es $O(1)$\\
	Armar la soluci\'on es $O(n)$\\
	Mover un comenzal de una lista a otra es $O(1)$\\
	   (ya sea vaciando una lista de principio a fin o removiendo del iterador)\\
	
	En peor caso el algoritmo recorre todos los nodos del arbol y estos son $2^{n+1} - 1$
	o sea $O(2^{n})$
	Por cada vez que recorre un nodo itera sobre todos los comenzales insatisfechos restantes
	En peor caso esto es $O(m)$
	
	Esto deja el algoritmo en una complejidad teorica de $O(2^{n}*m)$\\
	Considerando que n es acotado por la cantidad de letras en el alfabeto ingles (26) el algoritmo queda dependiendo solo de m o sea $O(m)$
	
	Para describir la complejidad en funci\'on el tamaño de entrada debemos considerar que cada comenzal puede llegar a tener hasta 26 preferencias, estos son 52 caracteres por comenzal\\
	Definimos el tamaño de entrada como:\\
		$T = log(m*n*2)$\\
	Sabiendo que n es acotado tomamos:\\
		$T = log(m)$\\
	Como la complejidad del algoritmo es $O(m)$ despejamos $n$ en funcion de $T$:\\
		$m = 2^{T}$\\
	\subsection{Tests}
	\textbf{Tipo1:} Un estudio poco profundo nos dir\'ia que los peores casos son aquellos que tiene todas las permutaciones. A estos los llamaremos $Tipo 1$\\
	Ej.
	\begin{verbatim}
	3
	+A+B+C;
	+A+B-C;
	+A-B+C;
	+A-B-C;
	-A+B+C;
	-A+B-C;
	-A-B+C;
	-A-B-C;
	.
	\end{verbatim}
	\textbf{Tipo2:}	Evaluando un poco mejor el algoritmo pudimos observar que los peores casos para cada tamaño de entrada los tendr\'a cuando tenga que evaluar en la mayoria de los comenzales en cada ingrediente.\\
	Sabiendo que el algoritmo primero intenta poner el ingrediente y luego, en caso que no haya solucion prueba no poniendolo lo obligamos a hacer el mayor numero de operaciones por la rama true.\\
	Tambien tenemos que procurar que no termine hasta haber revisado el último ingrediente asi que ponemos algun comenzal que tenga una preferencia contraria. Si ese comenzal tiene mas de una preferencia entonces se podria satisfacer evitando que se revisen mas ingredientes asi que no le ponemos mas.
	Los peores casos serian de la forma:
	\begin{verbatim}
	3
	+A+B+C;
	+A+B+C;
	 ...
	+A+B-C;
	+A-B;
	-A;
	.
	\end{verbatim}
	\textbf{Tipo3:} Finalmente observamos que los casos de $Tipo 2$ descartaban la decisi\'on de poner un ingrediente casi de inmediato as\'i que intentamos buscando un caso peor aún y nos pusimos la meta de no descartar letras con el podado y ademas que evalue la mayor cantidad posible de comenzales en cada nodo. La soluci\'on fue esta:
	\begin{verbatim}
	26
	+A+B+C+D+E+F+G+H+I+J+K+L+M+N+O+P+Q+R+S+T+U+V+W+X+Y+Z;
	+Z;
	+Z;
	 ...
	+Z;
	-Z;
	.
	\end{verbatim}	
	\subsection{Gr\'aficos}
	%grafico tipo 1
	%grafico tipo 2
	%grafico tipo 3
	Se puede ver en los tres gr\'aficos de peores casos que las mediciones obtenidas concuerdan con la complejidad teorica que habiamos calculado.
	Tambien se puede observar que las constantes utilizadas para comparar las mediciones con la funci\'on son mucho menores de lo que habiamos calculado en un primer momento como $2^{26}$.
	Esto puede deberse a que si un comenzal no es marcado en una decisi\'on sobre un ingrediente, puede ser marcado en la contraria achicando el conjunto de comenzales a evaluar.
	%grafico comparativo
	En este ultimo gr\'afico se puede comparar las mediciones de los tres tipos de casos juntas. Se puede ver que efectivamente el caso $Tipo 3$ es el peor de todos ya que el primer comenzal hace participar todos los ingredientes y nunca se filtran los comenzales hasta llegar al último ingrediente.
	\subsection{Conclusiones}
\newpage


% Problema3
\section{Problema3: Conjetura de Goldbach.}
\label{sec:problema3}
	\subsection{Introducci\'on}
	
		En matem\'atica una conjetura es una afirmaci\'on que no ha sido demostrada, pero basado en pruebas emp\'iricas parecer\'ia ser cierta. En este contexto la Conjetura de Goldbach o Conjetura fuerte de Goldbach intenta expresar una verdad una relaci\'on entre pares y primos que no ha sido a\'un verificada en su totalidad, dicha conjetura enuncia que:\\
		
		Todo n\'umero par mayor a dos puede ser escrito como suma de dos n\'umeros primos.\\
		
	En el presente trabajo implentaremos un algoritmo que, basado en la Conjetura de Goldbach y dado un n\'umero par mayor a dos, retorne dos primos que sumados obtengan dicho n\'umero.
	
	Utilizaremos la t\'ecnica de backtraking para generar posibles soluciones e ir al mismo 
tiempo realizando podas para no recorrer las que no los sean.

	Se analizar\'a tambi\'en la complejidad del algoritmo en base al tama\~{n}o de la entrada utilizando modelos de complejidad.
		
	Finalmente se realizar\'an gr\'aficas y analizar\'an peores casos, casos promedios y posibles casos patol\'ogicos.
	
	\subsection{Explicaci\'on de la soluci\'on}
	
	Como precondici\'on para el algoritmo el n\'umero n ingresado deber\'a ser par. A continuaci\'on
	el algoritmo ir\'a generando pares de n\'umeros que sumen n y que sean candidatos a soluci\'on del siguiente modo:\\
	
	1 + (n-1),
	2 + (n-2),
	...
	(n/2) + (n/2),
	...
	(n-2) + 2,
	(n-1) + 1\\
	
	\textbf{Poda1:} Lo primero que notamos es que al llegar a la mitad de pares generados la siguiente mitad ser\'a
	similar a la anterior ya que ser\'an los mismos sumandos pero invertidos con respecto a la suma.
	Entonces con verificar que sumandos son primos en la primera mitad basta para tambi\'en cubir los casos de la segunda mitad.
	
	La primera poda entonces es solo recorrer la primer mitad:\\
	
	1 + (n-1),
	2 + (n-2),
	...
	(n/2) + (n/2)\\
	
	\textbf{Poda2:} Tambi\'en puede verse que el n\'umero 1 no es de por si primo as\'i que cualquier suma en que participe no ser\'a una soluci\'on v\'alida. Podamos entonces la soluci\'on del 1.\\
	
	2 + (n-2),
	...
	(n/2) + (n/2)\\
	
	\textbf{Poda3:} Del mismo modo, tambi\'en podemos observar que cualquier n\'umero par, salvo el 2 no ser\'a primo ya que al ser par ser\'a divisible por 2. Excluimos entonces todas las sumas con pares en ellas salvo la que contenga al 2.\\
	
	2 + (n-2),
	3 + (n-3)
	...
	2m+1 (n-(2m+1))
	...
	(n/2)-1 + (n/2)+1\\
	
	\textbf{Poda4:} El caso del 2 podr\'iamos tratarlo a parte ya que la \'unica suma en la que participa es en la del 4 donde 4 = 2 + 2. No existe otra suma en la que el primo 2 aparezca ya que cualquier par que tenga como un sumando al 2 deberia tener como segundo sumando a otro n\'umero par y adem\'as primo y el \'unico que cumple esa condici\'on es el 2 caso que acabamos de excluir.\\
		
	3 + (n-3)
	...
	2m+1 (n-(2m+1))
	...
	(n/2)-1 + (n/2)+1\\	
	
	De esta forma generamos pares de n\'umeros que sumados dan el par inicial y que han sido previamente filtrados por las podas mencionadas. A continuaci\'on se verificar\'a si alguno de ellos es soluci\'on. La definici\'on de soluci\'on en este problema es para cada par si ambos n\'umeros son primos.
	
	Para el c\'alculo de si un n\'umero es primo verificaremos si el \'unico divisor positivo adem\'as del uno es si mismo, para ello se dividir\'a por todos los menores.
	
		\textbf{Poda5:} Un optimizaci\'on que se ha tenido en cuenta es verificar los divisores solo hasta la raiz cuadrada.
		
		\textbf{Poda6:} Tambi\'en, si al recorrer un par de sumandos notamos que ambos son iguales, verificaremos si es primo s\'olo uno de ellos, ya que es an\'alogo hacerlo con el par id\'entico.
		ej: Si el n considerado es 10 y se est\'a evaluando el par 5 + 5, solo verificaremos si 5 es primo una sola vez.
	
	Cabe aclarar que para optimizar el algoritmo la generaci\'on de candidatos y la verificaci\'on de soluci\'on se realizar\'an simult\'aneamente. No generaremos todas las soluciones y luego las verificaremos una a una, sino que verificaremos una a una a medida que las vayamos generando.
	
	\subsection{Pseudo-c\'odigo}

\begin{algorithmic}

	%Para mas referencia ver http://en.wikibooks.org/wiki/LaTeX/Algorithms_and_Pseudocode
	\FOR {cada n1,n2 candidatos podados}
        \IF {esPrimo(n1) y esPrimo(n2)}
            \STATE retornar n1, n2
        \ENDIF
	\ENDFOR

\end{algorithmic}	

	\subsection{Modelo elegido}
	
		Para el c\'alculo del orden utilizaremos primeramente el modelo \emph{Uniforme} ya que las operaciones b\'asicas que posee el algoritmo no son significativas ni parecen influir tanto como las iteraciones principales.
		
		De todos modos realizaremos tambi\'en un an\'alisis con el modelo \emph{logar\'itmico} para observar que si alguna operaci\'on b\'asica en particular prepondera sobre otras o puede afectar el algoritmo para alguna entrada en particular
		
		Analizaremos tambi\'en los peores casos y compararemos ambas gr\'aficas con ambos modelos.

\newpage		

\subsection{Complejidad temporal}
	
	La siguiente complejidad se calcula en base al modelo \emph{Uniforme}. 
	
	A continuaci\'on se describe el algoritmo donde se ha asignado a cada paso relevante las complejidades correpondientes:

%RESTAURAR	Aca antes decia verbatim ver si esto anda
%\begin{alltt}
	Paso1:    Para cada n1,n2 candidatos O(n/4)
	Paso2:       Si esPrimo(n1) y esPrimo(n2) entonces 	O($\sqrt{n1}$) + O($\sqrt{n2}$)
	Paso3:         retornar n1, n2
	Paso4:       Fin Si
	Paso5:    Fin Para 
%\end{alltt}	

		
	\textbf{Paso1:} Comenzaremos recorriendo de todos los posibles candidatos solo la mitad, ya que la otra mitad corresponde a soluciones an\'alogas (Poda1) recorreremos entonces n/2 pares de cantidatos. De esa mitad solo interesar\'an los pares pares ya que si alguno no lo fuese ser\'ia primo (el caso de 4 se tratar\'a aparte) de este modo de los n/2 pares recorreremos solo la mitad es decir n/4. La complejidad de este ciclo es de O(n/4).\\
	
	\textbf{Paso2:} Este paso basar\'a su complejidad en la complejidad de \emph{esPrimo}.
esPrimo dado un entero positivo n recorre todos los valores menores verificando si alguno
es divisor. Una optimizaci\'on ha sido recorrer hasta valores hasta la raiz de este modo la complejidad de esPrimo es de $O(\sqrt{n})$ que de todos modos diremos que es acotable por O(n).\\

De esta forma calculamos el costo del algoritmo recorriendo solo los pares impares hasta la mitad. Para ayudar a calcular este orden definamos entonces la funci\'on\\ verificarSoluci\'on(i,n) como esPrimo(i) $\wedge$ esPrimo(n-i);\\

	\begin{center}
	$\displaystyle\sum\limits_{i=1}^{n/4}  verificarSolucion(2 \cdot i+1,n)$.\\
	\end{center}
	
	\begin{center}
	$\displaystyle\sum\limits_{i=1}^{n/4} esPrimo(2 \cdot i+1)+esPrimo(n-(2 \cdot i+1))$.\\
	\end{center}
	
	\begin{center}
	Como esPrimo(n) es O($\sqrt(n)$) $\subset$ O(n) es acotable por O(n).\\
	\end{center}

	\begin{center}
	$\displaystyle\sum\limits_{i=1}^{n/4} (2 \cdot i+1) + n - (2 \cdot i+1)$.\\
	\end{center}
	
	\begin{center}
	Simplificando los t\'erminos $(2 \cdot i+1) $:\\
	\end{center}

	\begin{center}
  $\displaystyle\sum\limits_{i=1}^{n/4} n$\\
	\end{center}
	
	\begin{center}
	$\frac{n}{4} \cdot n = {\frac{n^2}{4}}$ es $O(n^2)$.\\ 
	\end{center}
	
	Ahora bien, para describir la complejidad en funci\'on del tama\~{n}o de la entrada debemos tener en cuenta la representaci\'on del n\'umero de entrada n en la computadora.
	Un n\'umero n ser\'a representado como $\log n$ bits.
	
	Definimos entonces el tama\~{n}o de entrada como:\\
	
	\begin{center}
	$T = \log n$\\
	\end{center}
	
	Si respejamos n para describir la complejidad en funci\'on de T:
	
	\begin{center}
	$2^T = n$\\
	\end{center}
	
	Como la complejidad de nuestro algoritmo es de $O(n^2)$ aplicamos cuadrado a ambos lados para ver la complejidad en T:
	
	\begin{center}
	$(2^T)^2 = n^2$\\
	\end{center}
	
	\begin{center}
	$(2^{2T}) = n^2$\\
	\end{center}
	
	La complejidad temporal en base a T es exponencial del orden de $O(2^{2T})$
	
	\subsection{Tests}
	\subsection{Gr\'aficos}
	
	\begin{center}
	%RESTAURAR
	%\includegraphics{ComplejidadGoldbachUniforme.jpg}
	\end{center}
	
	\subsection{Conclusiones}
\newpage


\end{document}
