	\documentclass[11pt, a4paper, spanish]{article}

\usepackage{alltt}

%%%%%%%%%% COMIENZO DEL PREAMBULO %%%%%%%%%%

%Info sobre este documento
\author{Mart\'n Cammi}
\title{Trabajo Pr\'actico de Algoritmos y Estucturas de datos III}

%\usepackage{infostyle}                                                  % provee un look & feel similar a un documento Word
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}  % m\'argenes
\usepackage[ansinew]{inputenc}                                           % permite que los acentos del estilo \'a\'e\'i\'o\'u salgan joya
\usepackage[spanish, activeacute]{babel}                                 % idioma espaniol, acentos f\'aciles y deletreo de palabras
\usepackage{indentfirst}                                                 % permite indentar un parrafo a mano
\usepackage{caratula}                                                    % incluye caratula est\'andar
\usepackage{graphicx}                                                    % permite insertar gr\'aficos
\usepackage{color}                                                       % permite el uso de colores en el documento
\usepackage{amssymb}
\usepackage[pdfcreator={TexLive!, LaTeX2e con TeXnicCenter},
			pdfauthor={Grupo: "1"},
			pdftitle={Algoritmos III - Trabajo Pr\'actico 2},
			pdfsubject={Trabajo Pr\'actico 1},
			pdfkeywords={Prismas, Esferas, Punto de corte, puente, pizza},
			pdfstartview=FitH,            % Fits the width of the page to the window
			bookmarksnumbered,            % los bookmarks numerados se ven mejor...
			colorlinks,                   % links con bellos colores
			linkcolor=magenta]            % permite cambiar el color de los links
			{hyperref}                    % Permite jugar con algunas cosas que aparecer\'an en el PDF final

%RESTAURAR

\usepackage{algorithm}							% Permite tabular un codigo
\usepackage{algorithmic}
%\input{spanishAlgorithmic} % mi archivo de traducci\'on			

%\selectlanguage{spanish}

%\selectlanguage{spanish}
\linespread{1.3}                    % interlineado equivalente al 1.5 l\'ineas de Word...
\pagestyle{myheadings}              %encabezado personalizable con \markboth{}{}
\markboth{}{Algoritmos III  - Trabajo Pr\'actico 3 - Cammi, Garbi, Kretschmayer}
\headsep = 30pt                     % separaci\'on entre encabezado y comienzo del p\'arrafo

%\addtolength{\oddsidemargin}{-2cm}	% configuracion IDEAL!!!
%\addtolength{\textwidth}{4cm}
%\addtolength{\textheight}{2cm}

% macro 'todo' para To-Do's
\def\todo#1{\textcolor{red}{#1}}

% Macro 'borde' para un texto con borde
\newsavebox{\fmbox}
\newenvironment{borde}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}\\[10pt]}

%%%%%%%%%% FIN DEL PREAMBULO %%%%%%%%%%

\begin{document}

\materia{Algoritmos y Estucturas de datos III}
\submateria{Segundo Cuatrimestre de 2011}
\titulo{Trabajo Pr\'actico 3}
\subtitulo{Cartero Chino en grafo mixto.}
\grupo{Grupo: `1'}
\integrante{Cammi, Mart\'in}{676/02}{martincammi@gmail.com}
\integrante{Garbi, Sebasti\'an}{179/05}{garbyseba@gmail.com}
\integrante{Kretschmayer, Daniel}{310/99}{daniak@gmail.com}

\maketitle

\thispagestyle{empty}

\tableofcontents

\newpage


\textbf{Ejecuci\'on del TP}
\label{sec:ejecucion}

	\subsection{Lenguaje utilizado}
		
		El lenguaje utilizado para el trabajo pr\'actico ha sido \emph{Java}, compilando con la versi\'on 1.5 de la Virtual Machine.
		
		El trabajo se acompa\~{n}a con los fuentes de la soluci\'on que puede importarse en IDE de Eclipse o ejecutarse desde l\'inea de comandos.

	\subsection{Como ejecutar el TP}
	
	\textbf{\underline{Desde l\'inea de comandos}}
	\begin{itemize}
			\item{Posicionarse en el directorio Algo3Tp3}
			\item{Copiar all\'i el archivo de entrada para el problema i, por ejemplo Ej1.in}
			\item{Ejecutar el comando: \emph{java -cp ./bin problema1.Ej1}}
	\end{itemize}
	Esto generar\'a el archivo Ej1.out con la soluci\'on en el mismo directorio Algo3Tp3.

	\textbf{\underline{Desde el Eclipse}}
	
	Primero importaremos el proyecto:	
	
	\begin{itemize}
			\item{Seleccionar File $\Rightarrow$ Import.}
			\item{Seleccionar General $\Rightarrow$ Existing Projects into Workspace $\Rightarrow$ Next.}
			\item{Seleccionar el directorio llamado Algo3Tp3.}
			\item{Finish.}
	\end{itemize}
	
	Desde la vista de \textbf{Package Explorer} bajo el paquete \textbf{src} aparecer\'an tres paquetes más y dentro de cada uno de ellos los siguientes archivos de java:\\

	\begin{center}
		%\includegraphics[scale=0.65]{others/packageExplorer.png}\\
		COLOCAR IMAGEN CORRECTA
	\end{center}

\newpage

	Para ejecutar un problema:

	\begin{itemize}
			\item{Posicionarse en el directorio Algo3Tp3}
			\item{Copiar en el directorio Algo3Tp3 el archivo de entrada para el problema i, por ejemplo Ej1.in}
			\item{Con bot\'on derecho Run As $\Rightarrow$ Java Application. Se ejecutar\'a el problema seleccionado.}
	\end{itemize}
	Esto generar\'a el archivo Ej1.out con la soluci\'on en el mismo directorio Algo3Tp3.

\newpage


\section{Introducci\'on}

	En 1736 Leonhard Euler public\'o un trabajo en el cual resolv\'ia el denominado \emph{problema de los puentes de K\"{o}nigsberg}. La ciudad de K\"{o}ningsberg, actual Kaliningrado, Rusia, está dividida por el r\'io Pregel en 4 zonas, dos orillas (A y B), la isla de Kneiphof (C) y otras dos partes divididas por el río. (D y F). Las orillas estaban conectadas mediante 7 puentes. El problema consistía partir de una orilla y recorrer todos los puentes, recorri\'endo una sola vez cada uno y volviendo al punto de partida.\\

Este fu\'e el puntapié inicial para un tipo de problema que m'as adelante de modelar\'ia usando la teor\'ia de grafos. Este problema fue caracterizado por Euler y consist\'ia en encontrar un circuito que pasara por todas las aristas de un grafo una s\'ola vez volviendo al punto de partida.\\
 
M\'as de doscientos a\~{n}os m\'as tarde en 1962 el matemático chino Kwan Mei-Koo publicó un paper en el que abordaba un problema ligeramente similar, propon\'ia que si un grafo no pose\'ia un circuito Euleriano, podria quizás encontrar el circuito m\'as corto que pasara por todas las aristas aunque repitiera algunas de ellas. Este problema fue luego nombrado como "Problema del cartero chino".

\begin{center}
\centering \includegraphics[scale=0.70]{img/KaliningradoBridges.jpg}\\
\small{Imagen actual de la ciudad de Kaliningrado, en rojo figuran los puentes del problema original de K\"{o}nigsberg algunos cuales ya no existen hoy en d\'ia.}
\end{center}	

El problema tiene varias variantes, en este trabajo abordaremos la variante \emph{mixta} que consiste en intentar encontrar el m\'inimo circuito que pase por todas las aristas (no orientadas) y arcos (orientadas) de un grafo donde cada una tiene peso asignado.

\newpage
\section{Situaciones de la vida real}

    El algoritmo del cartero chino tiene múltiples aplicaciones en la vida cotidiana por ser

	\begin{itemize}
	\item \emph{Camiones de basura}: en donde los camiones deban recorrer las calles de una ciudad y volver al centro de tratamiento de basura. Las calles estar\'ian representadas por aristas y las intersecciones por v\'ertices. Las calles podr\'ian bien tener diferentes sentidos o sentidos únicos, y los pesos podr\'ian corresponder a la cantidad de basura que deban recolectar en ciertas zonas (ej zonas industriales)
	\end{itemize}

	\begin{itemize}
	\item \emph{Reparto de Volantes:} C\'alculo de ruta \'optima que pase por todas las calles de una ciudad al menos una vez para poder repartir volantes se publicidad. Las calles estar\'ian representadas por aristas y las intersecciones por v\'ertices. Podr\'ia asignarse un peso de 1 a cada arista siendo que no tiene mayor complejidad repartir volantes en una u otra cuadra.
	\end{itemize}

\newpage
\section{Heurística Constructiva}

	El \emph{algoritmo contructivo} se encargar\'a de tomar un grafo mixto y orientar sus aristas no orientadas y al mismo tiempo establecer un matching inicial.\\ Un matching consiste en agrupar pares de nodos ${(v,w)}$ tales que $d_{in} v > 0$ y $d_{out} w > 0$.

\begin{center}
\centering \includegraphics[scale=0.30]{img/Matching.png}\\
\small{En el grafo, los nodos 1 y 3 est\'an desbalanceados con respecto a $d_{in} y d_{out}$, m\'as a\'un $d_{in} 3 > d_{out} 3 y d_{out} 1 > d_{in} 1$ con lo cual pueden formar parte de un matching: [(1,3)]}
\end{center}

\begin{center}
\centering \includegraphics[scale=0.30]{img/Matching2.png}\\
\small{En el grafo, los nodos 0, 2, 3 y 4 est\'an desbalanceados con respecto a $d_{in} y d_{out}$, un matching posible para equiparar sus $d_{in} y  d_{out}$ ser\'ia: [(0,2)(3,4)]}
\end{center}

	Para ello ideamos diferentes m\'etodos para la orientaci\'on de todas las aristas y fuimos experimentando con 5 m\'etodos distintos, todos ellos bas\'andose en los grados de los nodos para la elecci\'on de un nodo con el cual empezar a orientar sus aristas. Los m\'etodos elegir:\\
	
  \begin{itemize}
	\item 1) Los nodos que tienen igual cantidad de aristas sin orientar que orientadas, y en caso de haber muchos, solo tomar\'a los primeros k nodos de ellos, donde k es un par\'ametro de entrada de la funci\'on.
	\item 2) Los nodos a partir de un cierto n\'umero, que es definido por el par\'ametro de entrada de la funci\'on.
	\item 3) Los nodos que tengan grado de nodo (sin orientar) mayor o igual al ALFA* nodoGradoMaximo.
	\item 4) Los nodos que tengan grado de entrada (orientado) mayor o igual al ALFA* nodoGradoMaximo..
	\item 5) Los nodos que tengan grado de salida (orientado) mayor o igual al ALFA* nodoGradoMaximo.
  \end{itemize}

Se entiende como \emph{nodoGradoMaximo} al nodo de mayor grado, contando aristas no orientadas.\\

Con cualquiera de estas posibilidades, siempre se intenta hacer un balance entre los grados que quedar\'an (solo quedar\'an grados de entrada y salida, ya que ser\'a completamente orientado). Realizando pequeñas pruebas terminamos optando por el m\'etodo n\'umero 3) ya que por ejemplo con el m\'etodo n\'umero 1) no pod\'iamos asegurar que siempre existieran tales nodos que cumplieran la condici\'on.\\

El segundo m\'etodo se basaba en el parametro para darle la longitud a la lista y no armaba la lista en base al cumplmiento de una condició\'on (ej porcentaje de ALFA)\\

El cuarto y quinto m\'etodo se buscan los nodos que tengan din o dout >= a la proporcion ALFA, pero esta proporcion estaba basada en el grado no orientado del m\'as grande y est\'abamos comparando grados no orientados contra grados orientados que no tenian necesariamente que tener relaci\'on.\\

Eligiendo el m\'etodo 3), en caso de no encontrar ning\'un nodo a orientar con estas opciones, encontr\'a los k primeros nodos (empezando desde 0), sea cual sea el grado de sus nodos. (donde k es el ALFA* nodoGradoMaximo)\\

Una vez que tenemos todo el grafo orientado, realizamos luego una etapa de matching entre los nodos que quedan con diferentes grado de entrada y de salida, y balanceamos a todos los nodos, para que queden con iguales grados de entrada como de salida, y el grafo quede Euleriano. Este matching lo calculamos con la distancia m\'inima de entre cada uno de los nodos, pero en el grafo original, por lo que todas las aristas agregadas, tienen distancia m\'inima entre ellas.\\

MENCIONAR DANTZIG

\newpage	
\section{Heurística de b\'usqueda Local}

	El algoritmo de b\'usqueda local se encargar\'a, dado uno un grafo orientado completamente y un matching inicial, de generar una vecindad. Un matching consiste en agrupar pares de nodos ${(v,w)}$ tales que $d_{in} v > 0$ y $d_{out} w > 0$.

Lo que realizaremos es cambiar el matching que hace entre los nodos (intercambiando los nodos de dos pares por vez) para obtener otro matching que sea una soluci\'on vecina. Calculamos as\'i todas las posibles soluciones y luego calculamos la que sea m\'inima y as\'i poder acercarnos a una soluci\'on mejor.\\

Notemos que, como los matching entre los nodos donde se ten\'ia que los grados de entrada y de salida no coincid\'ian se efect\'ua sobre el grafo original (y no con el orientado), esta es una soluci\'on \'optima para esa orientaci\'on. Luego, con el grafo totalmente orientado y Euleriano, calculamos el peso de todas las aristas, y llegamos al peso del camino requerido.\\


\newpage
De esta manera una vecindad dado un matching inicial ser\'ia:

\begin{center}
\centering \includegraphics[scale=0.30]{img/MatchingVecindad.png}\\
\small{Una soluci\'on es vecina de otra si y solo si los matchings de ambas soluciones difieren s\'olo en un intercambio entre dos pares de matchings, as\'i, en el Vecino 1 se han intercambiado los pares (0,1) y (2,3) del matching original, en el Vecino 2 los pares (0,5) y (4,5) y en el Vecino 3 los pares (2,3) y (4,5)}
\end{center}

\newpage
\section{Metaheuristica Grasp}

\section{pseudo-Algoritmo}

El siguiente es un pseudo-c\'odigo del algoritmo heur\'istico que realizamos para obtener el circuito Euleriano:\\

\noindent{\textbf{Algoritmo GRASP}}\\
Mientras no se superen las I iteraciones totales y las J iteraciones sin mejorar de GRASP hacer:

\begin{itemize}
	\item \textbf{Algoritmo Constructivo}
		\begin{itemize}
			\item 1) Calular Dantzig sobre el grafo.
			\item 2) Orientar todas las aristas no orientadas del grafo.
			\item 3) Obtener un matching inicial entre los nodos que tengan din != dout.
		\end{itemize}
	\textbf{Fin Algoritmo Constructivo}

	\item \textbf{Algoritmo B\'usqueda Local}\\
	\emph{Mientras} no se superen K iteraciones y no se haya encontrado un matching \'optimo hacer
	\begin{itemize}
		\item 4) Obtener los matchings vecinos y quedarse con el m\'inimo vecino
	\end{itemize}
	\emph{Fin Mientras}\\
	\textbf{Fin Algoritmo B\'usqueda Local}

	\item 5) Calcular los caminos mínimos entre los nodos del matching.
	\item 6) Calcular el circuito Euleriano\\


\end{itemize}


\newpage

\section{Complejidad}
Complejidades donde $n$ es la cantidad de nodos, $m_{1}$ la cantidad de aristas, $m_{2}$ la cantidad de arcos y $m$ = $m_{1} + m_{2}$ \\
\begin{itemize}
	\item Inicializar grafo (lectura de archivo)
	\begin{itemize}
		\item Inicializar la matriz de pesos $O(n^{2})$
		\item Inicializar las listas de adyacencias $O(n + m_{1} +m_{2})$
	\end{itemize}
	$O(n^{2} + m_{1} +m_{2}) \subseteq O(n^{2})$
	\item FuertementeConexo
	\begin{itemize}
		\item Inicializacion de listas de adyacencias $O(n + m_{1} + m_{2})$
		\item resetVisitados y checkVisitados recorren un array de bools de tamaño n. $O(n)$
		\item visitarNodos recorre recursivamente en DFS las adyacencias y marca los nodos que son accesibles desde el nodo $0$ $O(m_{1} + m_{2})$
	\end{itemize}
	$O(n + m_{1} + m_{2})$
	\item Calcular Dantzig
	\begin{itemize}	
		\item Inicializacion de la matriz de pesos de caminos minimos $O(n^{2})$
		\item 3 for anidados de $0$ a $n$ con operaciones de tiempo constante $O(n^{3})$
	\end{itemize}
	$O(n^{3})$
	\item sumaPesosEjes recorre todas las aristas y arcos de los nodos $O(m_{1} + m_{2})$
	\item Clonar el grafo $O(n^{2} + m_{1} + m_{2})$ para copiar las estructuras
	\item orientarTodasAristas
	\begin{itemize}
		\item $m_{1}$ iteraciones de
		\begin{itemize}
			\item encontrarNodoAOrientar: Busca cuales nodos cumplen la condicion dada $O(n)$
			\item eleccionNodoAOrientar: Elije segun el parametro pasado por cual nodo de la lista anterior va a continuar $O(n)$
			\item orientarNodo $O(1)$
		\end{itemize}
		$O(1+ n+ n) subset O(n)$
	\end{itemize}
	$O(m_{1} * n)$
	\item encontrarMatchingNodos
	\begin{itemize}
		\item inicializacion de arreglos de longitud $n$ $O(n)$
		\item para cada exedente de $Din$ arma una pareja con un $Dout$ y lo agrega en una lista con el peso calculado con $Dantzig$ $O(\sum_{i=1}^{n}{|din(i)-dout(i)|}/2)$ $\subseteq$ $O(m)$
	\end{itemize}
	$O(m + n)$
	\item encontrarMatchingDeMenorPeso: Dado un matching de tamaño $k$ devuelve el mejor matching que se puede obtener swapeando los destinos de solo dos items del matching original. $O(k^{2})$
	\item pesoMatching recorre una lista de tamaño a lo sumo $m$ $O(m)$
	\item agregarCaminosMatcheados
	\begin{itemize}
		\item inicializacion de matriz de tamaño $n*n$ $O(n^{2})$
		\item Para cada eje $(i,j)$ del matching (a lo sumo $m$ ejes)
		\begin{itemize}
			\item Si no esta calculado el $Dijkstra$ para el nodo $i$ $\rightarrow$ Calcula $Dijkstra$ sobre el grafo original y lo guarda $O(n^{2})$
			\item Recuperar el camino del $Dijkstra$ calculado para el nodo $i$ hasta el nodo $j$ $O(n)$
		\end{itemize}
		$O(n^{2})$ Si no esta calculado $Dijkstra$ (a lo sumo $n$ casos)\\
		$O(n)$ Si ya esta calculado $Dijkstra$
	\end{itemize}
	$O(m*n + n*n^{2})$ como $O(m)$ $\subseteq$ $O(n^{2})$ $\Rightarrow$ $O(m*n + n^{3})$ $\subseteq$ $O(n^{3})$
	\item Dijkstra
	\begin{itemize}
		\item Inicializacion de arreglos de int y bool de tamaño $n$ $O(n)$
		\item Para cada nodo $i$ ($n$ elementos)
		\begin{itemize}
			\item Minvertex $O(n)$
			\item Para cada adyacente del nodo $i$ actualiza el valor $O(d(i))$
		\end{itemize}
	\end{itemize}
	$O(n + \sum_{i=1}^{n}{(d(i) + n)})$ $\subseteq$ $O(n + 2*m + n*n)$ $\subseteq$ $O(n^{2})$
	\item encontrar circuito euleriano $O(2 * largo del circuito)$\\
	Donde largo del circuito puede ser en peor caso $m*n$ cuando todos los nodos tiene matching y todos los caminos agregados tiene longitud $n$\\
	$O(m*n)$
\end{itemize}
\newpage

\begin{algorithm}
	\caption{Main($grafo$)}
	\begin{algorithmic}
	\STATE Grafo $GrafoOriginal$ $\gets$ Inicializar con instancia
	\IF{ es fuertemente Conexo $GrafoOriginal$}
		\STATE $PesosCaminosMinimos$ $\gets$ calcularDantzig($GrafoOriginal$)
		\STATE $SumaOriginalPesos$ $\gets$ sumaPesosEjes($GrafoOriginal$)
		\STATE $SumaSolucionMejor$ $\gets$ $\infty$
		\STATE $GrafoCopiaMejor$ $\gets$ $NULL$
		\STATE $MatchingMejor$ $\gets$ $\emptyset$
		\WHILE{ no se alcanzan $MaximoIteracionesGrasp$ $\lor$ $MaximoIteracionesSinMejoraGrasp$}
			\STATE Grafo $GC$ $\gets$ copiarGrafo($GrafoOriginal$)
			\STATE $ParametroGRASP$ $\gets$ Random
			\STATE orientarTodasAristas($GC$,$ParametroGRASP$)
			\STATE $matching$ $\gets$ encontrarMatchingNodos($GC$,$ParametroGRASP$)
			\WHILE{ no se alcanza $MaximoIteracionesBusquedaLocal$ $\lor$ no se encontro un matching optimo}
				\STATE $matching$ $\gets$ encontrarMatchingDeMenorPeso($matching$,$pesosCaminosMinimos$)
			\ENDWHILE
			\STATE $pesoMatching$ $\gets$ pesoMatching($matchingMejor$)
			\STATE $sumaSolucion$ $\gets$ $pesoMatching + SumaOriginalPesos$
			\IF{ mejoro la solucion }
				\STATE $SumaSolucionMejor$ $\gets$ $sumaSolucion$
				\STATE $GrafoCopiaMejor$ $\gets$ $GC$
				\STATE $MatchingMejor$ $\gets$ $matching$
			\ENDIF
		\ENDWHILE
		\STATE agregarCaminosMatcheados($GrafoCopiaMejor$,$MatchingMejor$,$GrafoOriginal$)
		\STATE $circuito$ $\gets$ encontrarCircuitoEuleriano($GrafoCopiaMejor$)
		\RETURN $circuito$
	\ELSE
		\RETURN No hay Tour porque el grafo no era fuertemente conexo
	\ENDIF
	\end{algorithmic}
\end{algorithm}

\newpage
Complejidad:
	\begin{itemize}
	\item $O(n^{2})$ de inicializacion
	\item $O(n + m_{1} + m_{2})$ de fuertementeConexo
	\item $O(n^{3})$ de Dantzig
	\item $O(m_{1} + m_{2})$ de sumarPesosEjes
	\item $MaximoIteracionesGrasp$*
	\begin{itemize}
		\item $O(n^{2} + m_{1} + m_{2})$ de copiar el grafo
		\item $O(m_{1} * n)$ de orientarTodasLasAristas
		\item $O(m_{1} + m_{2} + n)$ de encontrarMatchingNodos
		\item $MaximoIteracionesBusquedaLocal$*
		\begin{itemize}
			\item $O(m^{2})$ de encontrarMatchingDeMenorPeso
		\end{itemize}
		\item $O(m)$ de calcular peso del matching
	\end{itemize}
	\item $O(n^{3})$ de agregarCaminosMatcheados
	\item $O(m*n)$ de encontrar el CircuitoEuleriano
	\end{itemize}
Para grafos que no son fuertemente conexos la complejidad es $O(n^{2} + m)$\\	
Para las instancias interesantes del problema la complejidad esta dada por:
$O(n^{2} + n + m + n^{3} + m + \\MaximoIteracionesGrasp*(n^{2} + m + m_{1} * n + m + n + MaximoIteracionesBusquedaLocal*(m^{2}) + m ) + n^{3} + m*n)$ $\subseteq$
$O(n^{3} + m^{2} + m*n)$ $\subseteq$ $O(n^{3} + m^{2})$\\
%Como sabemos que el grafo es fuertemente conexo $\Rightarrow$ $ O(n) \subseteq O(m)$ $\Rightarrow$ la complejidad es\\
%$O(n^{3} + m^{2})$ $\subseteq$ $O(n*m^{2})$
\\
Definimos el tamaño de entrada como:
	\begin{center}	
	$T = log(n) + log(m_{1}) + log(m_{2}) + \sum_{i=1}^{m_{1} + m_{2}}{(log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}))}$\\
	Como $log(n) + log(m_{1}) + log(m_{2}) > 0 \Rightarrow$\\
	$T > \sum_{i=1}^{m_{1} + m_{2}}{(log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}))}$\\
	Tambien sabemos que para cada eje $log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}) > 1 \Rightarrow$\\
	$T > \sum_{i=1}^{m_{1} + m_{2}}{1} = m_{1} + m_{2} = m$ \\
	Sabemos que el grafo es fuertemente conexo asi que $n$ es del orden de $m$ $\Rightarrow$\\
	$T > m \geq n$ \\
	Dado la complejidad calculada y las cotas para $T$ vale $O(n^{3} + m^{2})$ $\subseteq$ $O(T^{3}+T^{2})$ $\subseteq$ $O(T^{3})$
	\end{center}

\newpage

\section{Tests}

\section{Gr\'aficos}

\end{document}
