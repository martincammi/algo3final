	\documentclass[11pt, a4paper, spanish]{article}

\usepackage{alltt}

%%%%%%%%%% COMIENZO DEL PREAMBULO %%%%%%%%%%

%Info sobre este documento
\author{Mart\'n Cammi}
\title{Trabajo Pr\'actico de Algor\'itmos y Estucturas de datos III}

%\usepackage{infostyle}                                                  % provee un look & feel similar a un documento Word
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}  % m\'argenes
\usepackage[ansinew]{inputenc}                                           % permite que los acentos del estilo \'a\'e\'i\'o\'u salgan joya
\usepackage[spanish, activeacute]{babel}                                 % idioma espaniol, acentos f\'aciles y deletreo de palabras
\usepackage{indentfirst}                                                 % permite indentar un parrafo a mano
\usepackage{caratula}                                                    % incluye caratula est\'andar
\usepackage{graphicx}                                                    % permite insertar gr\'aficos
\usepackage{color}                                                       % permite el uso de colores en el documento
\usepackage{amssymb}
\usepackage[pdfcreator={TexLive!, LaTeX2e con TeXnicCenter},
			pdfauthor={Grupo: "1"},
			pdftitle={Algoritmos III - Trabajo Pr\'actico 3},
			pdfsubject={Trabajo Pr\'actico 1},
			pdfkeywords={Prismas, Esferas, Punto de corte, puente, pizza},
			pdfstartview=FitH,            % Fits the width of the page to the window
			bookmarksnumbered,            % los bookmarks numerados se ven mejor...
			colorlinks,                   % links con bellos colores
			linkcolor=magenta]            % permite cambiar el color de los links
			{hyperref}                    % Permite jugar con algunas cosas que aparecer\'an en el PDF final

%RESTAURAR

\usepackage{algorithm}							% Permite tabular un codigo
\usepackage{algorithmic}
%\input{spanishAlgorithmic} % mi archivo de traducci\'on			

%\selectlanguage{spanish}

%\selectlanguage{spanish}
\linespread{1.3}                    % interlineado equivalente al 1.5 l\'ineas de Word...
\pagestyle{myheadings}              %encabezado personalizable con \markboth{}{}
\markboth{}{Algor\'itmos III  - Trabajo Pr\'actico 3 - Cammi, Garbi, Kretschmayer}
\headsep = 30pt                     % separaci\'on entre encabezado y comienzo del p\'arrafo

%\addtolength{\oddsidemargin}{-2cm}	% configuracion IDEAL!!!
%\addtolength{\textwidth}{4cm}
%\addtolength{\textheight}{2cm}

% macro 'todo' para To-Do's
\def\todo#1{\textcolor{red}{#1}}

% Macro 'borde' para un texto con borde
\newsavebox{\fmbox}
\newenvironment{borde}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}\\[10pt]}

%%%%%%%%%% FIN DEL PREAMBULO %%%%%%%%%%

\begin{document}

\materia{Algor\'itmos y Estucturas de datos III}
\submateria{Segundo Cuatrimestre de 2011}
\titulo{Trabajo Pr\'actico 3}
\subtitulo{Cartero Chino en grafo mixto.}
\grupo{Grupo: `1'}
\integrante{Cammi, Mart\'in}{676/02}{martincammi@gmail.com}
\integrante{Garbi, Sebasti\'an}{179/05}{garbyseba@gmail.com}
\integrante{Kretschmayer, Daniel}{310/99}{daniak@gmail.com}

\maketitle

\thispagestyle{empty}

\tableofcontents

\newpage


\textbf{Ejecuci\'on del TP}
\label{sec:ejecucion}

	\subsection{Lenguaje utilizado}
		
		El lenguaje utilizado para el trabajo pr\'actico ha sido \emph{Java}, compilando con la versi\'on 1.5 de la Virtual Machine.
		
		El trabajo se acompa\~{n}a con los fuentes de la soluci\'on que puede importarse en IDE de Eclipse o ejecutarse desde l\'inea de comandos.

	\subsection{Como ejecutar el TP}
	
	\textbf{\underline{Desde l\'inea de comandos}}
	\begin{itemize}
			\item{Posicionarse en el directorio Algo3Tp3}
			\item{Copiar all\'i el archivo de entrada para el problema i, por ejemplo Ej1.in}
			\item{Ejecutar el comando: \emph{java -cp ./bin problema1.Ej1}}
	\end{itemize}
	Esto generar\'a el archivo Ej1.out con la soluci\'on en el mismo directorio Algo3Tp3.

	\textbf{\underline{Desde el Eclipse}}
	
	Primero importaremos el proyecto:	
	
	\begin{itemize}
			\item{Seleccionar File $\Rightarrow$ Import.}
			\item{Seleccionar General $\Rightarrow$ Existing Projects into Workspace $\Rightarrow$ Next.}
			\item{Seleccionar el directorio llamado Algo3Tp3.}
			\item{Finish.}
	\end{itemize}
	
	Desde la vista de \textbf{Package Explorer} bajo el paquete \textbf{src} aparecer\'an tres paquetes más y dentro de cada uno de ellos los siguientes archivos de java:\\

	\begin{center}
		%\includegraphics[scale=0.65]{others/packageExplorer.png}\\
		COLOCAR IMAGEN CORRECTA
	\end{center}

\newpage

	Para ejecutar un problema:

	\begin{itemize}
			\item{Posicionarse en el directorio Algo3Tp3}
			\item{Copiar en el directorio Algo3Tp3 el archivo de entrada para el problema i, por ejemplo Ej1.in}
			\item{Con bot\'on derecho Run As $\Rightarrow$ Java Application. Se ejecutar\'a el problema seleccionado.}
	\end{itemize}
	Esto generar\'a el archivo Ej1.out con la soluci\'on en el mismo directorio Algo3Tp3.

\newpage


\section{Introducci\'on}

	En 1736 Leonhard Euler public\'o un trabajo en el cual resolv\'ia el denominado \emph{problema de los puentes de K\"{o}nigsberg}. La ciudad de K\"{o}ningsberg, actual Kaliningrado, Rusia, está dividida por el r\'io Pregel en 4 zonas, dos orillas (A y B), la isla de Kneiphof (C) y otras dos partes divididas por el río. (D y F). Las orillas estaban conectadas mediante 7 puentes. El problema consistía partir de una orilla y recorrer todos los puentes, recorri\'endo una sola vez cada uno y volviendo al punto de partida.\\

Este fu\'e el puntapié inicial para un tipo de problema que m'as adelante de modelar\'ia usando la teor\'ia de grafos. Este problema fue caracterizado por Euler y consist\'ia en encontrar un circuito que pasara por todas las aristas de un grafo una s\'ola vez volviendo al punto de partida.\\
 
M\'as de doscientos a\~{n}os m\'as tarde en 1962 el matemático chino Kwan Mei-Koo publicó un paper en el que abordaba un problema ligeramente similar, propon\'ia que si un grafo no pose\'ia un circuito Euleriano, podria quizás encontrar el circuito m\'as corto que pasara por todas las aristas aunque repitiera algunas de ellas. Este problema fue luego nombrado como "Problema del cartero chino".

\begin{center}
\centering \includegraphics[scale=0.70]{img/KaliningradoBridges.jpg}\\
\small{Imagen actual de la ciudad de Kaliningrado, en rojo figuran los puentes del problema original de K\"{o}nigsberg algunos cuales ya no existen hoy en d\'ia.}
\end{center}	

El problema tiene varias variantes, en este trabajo abordaremos la variante \emph{mixta} que consiste en intentar encontrar el m\'inimo circuito que pase por todas las aristas (no orientadas) y arcos (orientadas) de un grafo donde cada una tiene peso asignado.

\newpage
\section{Situaciones de la vida real}

    El algor\'itmo del cartero chino tiene múltiples aplicaciones en la vida cotidiana por ser

	\begin{itemize}
	\item \emph{Camiones de basura}: en donde los camiones deban recorrer las calles de una ciudad y volver al centro de tratamiento de basura. Las calles estar\'ian representadas por aristas y las intersecciones por v\'ertices. Las calles podr\'ian bien tener diferentes sentidos o sentidos únicos, y los pesos podr\'ian corresponder a la cantidad de basura que deban recolectar en ciertas zonas (ej zonas industriales)
	\end{itemize}

	\begin{itemize}
	\item \emph{Reparto de Volantes:} C\'alculo de ruta \'optima que pase por todas las calles de una ciudad al menos una vez para poder repartir volantes se publicidad. Las calles estar\'ian representadas por aristas y las intersecciones por v\'ertices. Podr\'ia asignarse un peso de 1 a cada arista siendo que no tiene mayor complejidad repartir volantes en una u otra cuadra.
	\end{itemize}

\newpage
\section{Heurística Constructiva}

	El \emph{algor\'itmo contructivo} se encargar\'a de tomar un grafo mixto y orientar sus aristas no orientadas y al mismo tiempo establecer un matching inicial.\\ Un matching consiste en agrupar pares de nodos ${(v,w)}$ tales que $d_{in} v > 0$ y $d_{out} w > 0$.

\begin{center}
\centering \includegraphics[scale=0.30]{img/Matching.png}\\
\small{En el grafo, los nodos 1 y 3 est\'an desbalanceados con respecto a $d_{in}$ y $d_{out}$, m\'as a\'un $d_{in} 3 > d_{out} 3$ y $d_{out} 1 > d_{in} 1$ con lo cual pueden formar parte de un matching: [(1,3)]}
\end{center}

\begin{center}
\centering \includegraphics[scale=0.30]{img/Matching2.png}\\
\small{En el grafo, los nodos 0, 2, 3 y 4 est\'an desbalanceados con respecto a $d_{in}$ y $d_{out}$, un matching posible para equiparar sus $d_{in}$ y $d_{out}$ ser\'ia: [(0,2)(3,4)]}
\end{center}

	Para ello ideamos diferentes m\'etodos para la orientaci\'on de todas las aristas y fuimos experimentando con 5 m\'etodos distintos, todos ellos bas\'andose en los grados de los nodos para la elecci\'on de un nodo con el cual empezar a orientar sus aristas. Los m\'etodos elegir:\\
	
  \begin{itemize}
	\item 1) Los nodos que tienen igual cantidad de aristas sin orientar que orientadas, y en caso de haber muchos, solo tomar\'a los primeros k nodos de ellos, donde k es un par\'ametro de entrada de la funci\'on.
	\item 2) Los nodos a partir de un cierto n\'umero, que es definido por el par\'ametro de entrada de la funci\'on.
	\item 3) Los nodos que tengan grado de nodo (sin orientar) mayor o igual al ALFA* nodoGradoMaximo.
	\item 4) Los nodos que tengan grado de entrada (orientado) mayor o igual al ALFA* nodoGradoMaximo..
	\item 5) Los nodos que tengan grado de salida (orientado) mayor o igual al ALFA* nodoGradoMaximo.
  \end{itemize}

Se entiende como \emph{nodoGradoMaximo} al nodo de mayor grado, contando aristas no orientadas.\\

Con cualquiera de estas posibilidades, siempre se intenta hacer un balance entre los grados que quedar\'an (solo quedar\'an grados de entrada y salida, ya que ser\'a completamente orientado). Realizando pequeñas pruebas terminamos optando por el m\'etodo n\'umero 3) ya que por ejemplo con el m\'etodo n\'umero 1) no pod\'iamos asegurar que siempre existieran tales nodos que cumplieran la condici\'on.\\

El segundo m\'etodo se basaba en el parametro para darle la longitud a la lista y no armaba la lista en base al cumplmiento de una condició\'on (ej porcentaje de ALFA)\\

El cuarto y quinto m\'etodo se buscan los nodos que tengan din o dout $\geq$ a la proporcion ALFA, pero esta proporcion estaba basada en el grado no orientado del m\'as grande y est\'abamos comparando grados no orientados contra grados orientados que no tenian necesariamente que tener relaci\'on.\\

Eligiendo el m\'etodo 3), en caso de no encontrar ning\'un nodo a orientar con estas opciones, encontr\'a los k primeros nodos (empezando desde 0), sea cual sea el grado de sus nodos. (donde k es el ALFA* nodoGradoMaximo)\\

Una vez que tenemos todo el grafo orientado, realizamos luego una etapa de matching entre los nodos que quedan con diferentes grado de entrada y de salida, y balanceamos a todos los nodos, para que queden con iguales grados de entrada como de salida, y el grafo quede Euleriano. Este matching lo calculamos con el peso del camino minimo de entre cada uno de los nodos calculado sobre el grafo original utilizando Dantzig, ya que en esta etapa del algor\'itmo solo nos interesa saber el peso del camino m\'inimo y no como esta compuesto.\\


\newpage	
\section{Heurística de b\'usqueda Local}

	El algor\'itmo de b\'usqueda local se encargar\'a, dado uno un grafo orientado completamente, un matching inicial y el grafo original, de buscar en la vecindad un mejor matching. Un matching consiste en agrupar pares de nodos ${(v,w)}$ tales que $d_{in} v > 0$ y $d_{out} w > 0$.\\

Lo que haermos para conseguir una soluci\'on vecina es intercambiar en un matching dos pares de nodos para obtener as\'i un nuevo matching. Calculamos de esta manera todas las posibles soluciones vecinas intercambiando solo nodos entre dos pares y luego de todas ellas obtenemos la que sea m\'inima y as\'i poder acercarnos a una soluci\'on mejor.\\

Esta definici\'on de vecindad tiene un tamaño de $k^{2}$ donde $k$ es la cantidad de pares en el matching. Esto puede verse ya que para el intercambio de un par con otro existen $k-1$ posibilidades de otros pares. A su vez como la cantidad de pares en el matching es est\'a determinada por la diferencia de grados de entrada y salida de los nodos \'esta equivale a\\

\begin{center}
	$\displaystyle{\frac{\displaystyle\sum_{i=1}^{n}{|din(i)-dout(i)|}}{2}}$\\
\end{center}

\begin{center}
	$\displaystyle{\frac{\displaystyle\sum_{1 \leq i \leq n / din > dout}^{}{din(i)-dout(i)} + \displaystyle\sum_{1 \leq i \leq n / dout > din}^{}{dout(i)-din(i)} }{2}} \leq$\\
\end{center}

\begin{center}
	$\displaystyle{\frac{\displaystyle\sum_{1 \leq i \leq n / din > dout}^{}{din(i)} + \displaystyle\sum_{1 \leq i \leq n / dout > din}^{}{dout(i)} }{2}} \leq $\\
\end{center}

\begin{center}
	$\displaystyle{\frac{m + m}{2} = \frac{2 \cdot m}{2} = m} $\\
\end{center}

Asi que una vecindad tiene a lo sumo $m$ elementos.\\

A su vez la cantidad de posibles matchings diferentes que pueden existir es del orden de $k!$ ya en la elecci\'on de los pares para un nodo determinado existen $k-1$ posibilidades para su par, una vez establecido para el siguiente nodo habr\'a $k-2$ posibles pares y as\'i sucesivamente.

\newpage
Un ejemplo de una vecindad dado un matching inicial ser\'ia la siguiente:

\begin{center}
\centering \includegraphics[scale=0.30]{img/MatchingVecindad.png}\\
\small{Una soluci\'on es vecina de otra si y solo si los matchings de ambas soluciones difieren s\'olo en un intercambio entre dos pares de matchings, as\'i, en el Vecino 1 se han intercambiado los pares (0,1) y (2,3) del matching original, en el Vecino 2 los pares (0,5) y (4,5) y en el Vecino 3 los pares (2,3) y (4,5)}
\end{center}

\newpage
\section{Metaheuristica Grasp}

Esta etapa del algor\'itmo realiza varias iteraciones de los algor\'itmos de las heurísticas constructiva y de búsqueda local, decidiendo mediante experimentacíon el nivel de aleatoriedad agregado al algor\'itmo constructivo, el tamaño de la vecindad a visitar y la cantidad de veces que se intentar una solución nueva.\\

El parametro $CANT\_ITERACIONES\_MAXIMA$ define el máximo de veces que se construirá una solución inicial.\\
El parametro $CANT\_ITERACIONES\_SIN\_MEJORAR$ se usa como condición de corte, si no se pudo encontrar una solución mejor en tantas iteraciones de $GRASP$ se corta la ejecución y se devuelve la mejor hasta el momento.\\
El parametro $CANT\_ITERACIONES\_BUSQUEDA\_LOCAL$ define el tamaño maximo que tendra la vecindad ya que este puede ser exponencial en el tamaño del matching.\\

Como no tenemos el valor real de la solución óptima, medimos la calidad de las soluciones como el porcentaje de peso agregado en la solución con respecto al peso total de las aristas del grafo original.\\

El valor decidido para $ALFA$ fue $0,1$.\\
\begin{center}
\centering \includegraphics[scale=0.40]{img/VariacionAlfa.jpg}\\
\centering \includegraphics[scale=0.40]{img/VariacionAlfaComplejidad.jpg}\\
\small{Como se puede observar en las gráficos de las mediciones tomadas para las mismas instancias con distintos valores para $ALFA$, se obtuvieron los mejores resultados para el valor $0,1$ y las complejidades practica para ese valor son bastante razonables.}
\end{center}	

El valor decidido para $CANT\_ITERACIONES\_SIN\_MEJORAR$ fue $10$.\\
\begin{center}
\centering \includegraphics[scale=0.40]{img/VariacionItSinMejora.jpg}\\
\centering \includegraphics[scale=0.40]{img/VariacionItSinMejoraComplejidad.jpg}\\
\small{Tomamos esta decisión ya que obsevamos que la complejidad crece mucho y la mejora de la solución no es muy significativa}
\end{center}

El valor decidido para $CANT\_ITERACIONES\_MAXIMA$ fue $200$, ya que en ninguno de los casos evaluados llegó a cortar por esa cota.
El valor decidido para $CANT\_ITERACIONES\_BUSQUEDA\_LOCAL$ fue $50$.

\section{pseudo-algor\'itmo}

El siguiente es un pseudo-c\'odigo del algor\'itmo heur\'istico que realizamos para obtener el circuito Euleriano:\\

\noindent{\textbf{algor\'itmo GRASP}}\\
Mientras no se superen las I iteraciones totales y las J iteraciones sin mejorar de GRASP hacer:

\begin{itemize}
	\item \textbf{Algor\'itmo Constructivo}
		\begin{itemize}
			\item 1) Calular Dantzig sobre el grafo.
			\item 2) Orientar todas las aristas no orientadas del grafo.
			\item 3) Obtener un matching inicial entre los nodos que tengan din $\neq$ dout.
		\end{itemize}
	\textbf{Fin Algor\'itmo Constructivo}

	\item \textbf{Algor\'itmo B\'usqueda Local}\\
	\emph{Mientras} no se superen K iteraciones y no se haya encontrado un matching \'optimo hacer
	\begin{itemize}
		\item 4) Obtener los matchings vecinos y quedarse con el m\'inimo vecino
	\end{itemize}
	\emph{Fin Mientras}\\
	\textbf{Fin Algor\'itmo B\'usqueda Local}

	\item 5) Calcular los caminos mínimos entre los nodos del matching.
	\item 6) Calcular el circuito Euleriano\\


\end{itemize}


\newpage

\section{Complejidad}
Complejidades donde $n$ es la cantidad de nodos, $m_{1}$ la cantidad de aristas, $m_{2}$ la cantidad de arcos y $m$ = $m_{1} + m_{2}$ \\
\begin{itemize}
	\item Inicializar grafo (lectura de archivo)
	\begin{itemize}
		\item Inicializar la matriz de pesos $O(n^{2})$
		\item Inicializar las listas de adyacencias $O(n + m_{1} +m_{2})$
	\end{itemize}
	En total: $O(n^{2} + m_{1} +m_{2}) \subseteq O(n^{2})$
	\item FuertementeConexo
	\begin{itemize}
		\item Inicializacion de listas de adyacencias $O(n + m_{1} + m_{2})$
		\item resetVisitados y checkVisitados recorren un array de bools de tamaño $n$. $O(n)$
		\item visitarNodos recorre recursivamente en DFS las adyacencias y marca los nodos que son accesibles desde el nodo $0$ $O(m_{1} + m_{2})$
	\end{itemize}
	En total: $O(n + m_{1} + m_{2})$
	\item Calcular Dantzig
	\begin{itemize}	
		\item Inicializacion de la matriz de pesos de caminos minimos $O(n^{2})$
		\item 3 for anidados de $0$ a $n$ con operaciones de tiempo constante $O(n^{3})$
	\end{itemize}
	En total: $O(n^{3})$
	\item sumaPesosEjes recorre todas las aristas y arcos de los nodos $O(m_{1} + m_{2})$
	\item Clonar el grafo $O(n^{2} + m_{1} + m_{2})$ para copiar las estructuras
	\item orientarTodasAristas
	\begin{itemize}
		\item $m_{1}$ iteraciones de
		\begin{itemize}
			\item encontrarNodoAOrientar: Busca cuales nodos cumplen la condicion dada $O(n)$
			\item eleccionNodoAOrientar: Elije segun el parametro pasado por cual nodo de la lista anterior va a continuar $O(n)$
			\item orientarNodo $O(1)$
		\end{itemize}
		$O(1+ n+ n) subset O(n)$
	\end{itemize}
	En total: $O(m_{1} * n)$
\newpage
	\item encontrarMatchingNodos
	\begin{itemize}
		\item Inicializacion de arreglos de longitud $n$ $O(n)$
		\item para cada exedente de $Din$ arma una pareja con un $Dout$ y lo agrega en una lista con el peso calculado con $Dantzig$ $O(\sum_{i=1}^{n}{|din(i)-dout(i)|}/2)$ $\subseteq$ $O(m)$
	\end{itemize}
	En total: $O(m + n)$
	\item encontrarMatchingDeMenorPeso: Dado un matching de tamaño $k$ devuelve el mejor matching que se puede obtener swapeando los destinos de solo dos items del matching original. \\En total: $O(k^{2})$
	\item pesoMatching recorre una lista de tamaño a lo sumo \\
	En total: $m$ $O(m)$
	\item agregarCaminosMatcheados
	\begin{itemize}
		\item Inicializacion de matriz de tamaño $n*n$ $O(n^{2})$
		\item Para cada eje $(i,j)$ del matching (a lo sumo $m$ ejes)
		\begin{itemize}
			\item Si no esta calculado el $Dijkstra$ para el nodo $i$ $\rightarrow$ Calcula $Dijkstra$ sobre el grafo original y lo guarda $O(n^{2})$
			\item Recuperar el camino del $Dijkstra$ calculado para el nodo $i$ hasta el nodo $j$ $O(n)$
		\end{itemize}
		$O(n^{2})$ Si no esta calculado $Dijkstra$ (a lo sumo $n$ casos)\\
		$O(n)$ Si ya esta calculado $Dijkstra$
	\end{itemize}
	En total: $O(m*n + n*n^{2})$ como $O(m)$ $\subseteq$ $O(n^{2})$ $\Rightarrow$ $O(m*n + n^{3})$ $\subseteq$ $O(n^{3})$
	\item Dijkstra
	\begin{itemize}
		\item Inicializacion de arreglos de int y bool de tamaño $n$ $O(n)$
		\item Para cada nodo $i$ ($n$ elementos)
		\begin{itemize}
			\item Minvertex $O(n)$
			\item Para cada adyacente del nodo $i$ actualiza el valor $O(d(i))$
		\end{itemize}
	\end{itemize}
	En total: $O(n + \sum_{i=1}^{n}{(d(i) + n)})$ $\subseteq$ $O(n + 2*m + n*n)$ $\subseteq$ $O(n^{2})$
	\item encontrar circuito euleriano $O(2 * largo del circuito)$\\
	Donde largo del circuito puede ser en peor caso $m*n$ cuando todos los nodos tiene matching y todos los caminos agregados tiene longitud $n$\\
	En total: $O(m*n)$
\end{itemize}
\newpage

\begin{algorithm}
	\caption{Main($grafo$)}
	\begin{algorithmic}
	\STATE Grafo $GrafoOriginal$ $\gets$ Inicializar con instancia
	\IF{ es fuertemente Conexo $GrafoOriginal$}
		\STATE $PesosCaminosMinimos$ $\gets$ calcularDantzig($GrafoOriginal$)
		\STATE $SumaOriginalPesos$ $\gets$ sumaPesosEjes($GrafoOriginal$)
		\STATE $SumaSolucionMejor$ $\gets$ $\infty$
		\STATE $GrafoCopiaMejor$ $\gets$ $NULL$
		\STATE $MatchingMejor$ $\gets$ $\emptyset$
		\WHILE{ no se alcanzan $MaximoIteracionesGrasp$ $\lor$ $MaximoIteracionesSinMejoraGrasp$}
			\STATE Grafo $GC$ $\gets$ copiarGrafo($GrafoOriginal$)
			\STATE $ParametroGRASP$ $\gets$ Random
			\STATE orientarTodasAristas($GC$,$ParametroGRASP$)
			\STATE $matching$ $\gets$ encontrarMatchingNodos($GC$,$ParametroGRASP$)
			\WHILE{ no se alcanza $MaximoIteracionesBusquedaLocal$ $\lor$ no se encontro un matching optimo}
				\STATE $matching$ $\gets$ encontrarMatchingDeMenorPeso($matching$,$pesosCaminosMinimos$)
			\ENDWHILE
			\STATE $pesoMatching$ $\gets$ pesoMatching($matchingMejor$)
			\STATE $sumaSolucion$ $\gets$ $pesoMatching + SumaOriginalPesos$
			\IF{ mejoro la solucion }
				\STATE $SumaSolucionMejor$ $\gets$ $sumaSolucion$
				\STATE $GrafoCopiaMejor$ $\gets$ $GC$
				\STATE $MatchingMejor$ $\gets$ $matching$
			\ENDIF
		\ENDWHILE
		\STATE agregarCaminosMatcheados($GrafoCopiaMejor$,$MatchingMejor$,$GrafoOriginal$)
		\STATE $circuito$ $\gets$ encontrarCircuitoEuleriano($GrafoCopiaMejor$)
		\RETURN $circuito$
	\ELSE
		\RETURN No hay Tour porque el grafo no era fuertemente conexo
	\ENDIF
	\end{algorithmic}
\end{algorithm}

\newpage

Complejidad:
	\begin{itemize}
	\item $O(n^{2})$ de inicializacion
	\item $O(n + m_{1} + m_{2})$ de fuertementeConexo
	\item $O(n^{3})$ de Dantzig
	\item $O(m_{1} + m_{2})$ de sumarPesosEjes
	\item $MaximoIteracionesGrasp$*
	\begin{itemize}
		\item $O(n^{2} + m_{1} + m_{2})$ de copiar el grafo
		\item $O(m_{1} * n)$ de orientarTodasLasAristas
		\item $O(m_{1} + m_{2} + n)$ de encontrarMatchingNodos
		\item $MaximoIteracionesBusquedaLocal$*
		\begin{itemize}
			\item $O(m^{2})$ de encontrarMatchingDeMenorPeso
		\end{itemize}
		\item $O(m)$ de calcular peso del matching
	\end{itemize}
	\item $O(n^{3})$ de agregarCaminosMatcheados
	\item $O(m*n)$ de encontrar el CircuitoEuleriano
	\end{itemize}
Para grafos que no son fuertemente conexos la complejidad es $O(n^{2} + m)$\\	
Para las instancias interesantes del problema la complejidad esta dada por:\\
$O(n^{2} + n + m + n^{3} + m + \\MaximoIteracionesGrasp*(n^{2} + m + m_{1} * n + m + n + MaximoIteracionesBusquedaLocal*(m^{2}) + m ) + n^{3} + m*n)$ $\subseteq$
$O(n^{3} + m^{2} + m*n)$ $\subseteq$ $O(n^{3} + m^{2})$\\
%Como sabemos que el grafo es fuertemente conexo $\Rightarrow$ $ O(n) \subseteq O(m)$ $\Rightarrow$ la complejidad es\\
%$O(n^{3} + m^{2})$ $\subseteq$ $O(n*m^{2})$
\\
Definimos el tamaño de entrada como:
	\begin{center}	
	$T = log(n) + log(m_{1}) + log(m_{2}) + \sum_{i=1}^{m_{1} + m_{2}}{(log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}))}$\\
	\end{center}

	Como $log(n) + log(m_{1}) + log(m_{2}) > 0 \Rightarrow$\\
	\begin{center}
	$T > \sum_{i=1}^{m_{1} + m_{2}}{(log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}))}$\\
	\end{center}

	Tambien sabemos que para cada eje $log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}) > 1 \Rightarrow$\\
	\begin{center}
	$T > \sum_{i=1}^{m_{1} + m_{2}}{1} = m_{1} + m_{2} = m$ \\
	\end{center}
	Sabemos que el grafo es fuertemente conexo asi que $n$ es del orden de $m$ $\Rightarrow$\\

	\begin{center}
	$T > m \geq n$ \\
	Dado la complejidad calculada y las cotas para $T$ vale $O(n^{3} + m^{2})$ $\subseteq$ $O(T^{3}+T^{2})$ $\subseteq$ $O(T^{3})$
	\end{center}

\newpage

\section{Tests}

\section{Gr\'aficos}

\end{document}
