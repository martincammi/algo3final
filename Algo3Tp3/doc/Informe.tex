	\documentclass[11pt, a4paper, spanish]{article}

\usepackage{alltt}

%%%%%%%%%% COMIENZO DEL PREAMBULO %%%%%%%%%%

%Info sobre este documento
\author{Mart\'n Cammi}
\title{Trabajo Pr\'actico de Algoritmos y Estucturas de datos III}

%\usepackage{infostyle}                                                  % provee un look & feel similar a un documento Word
\usepackage[top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}  % m\'argenes
\usepackage[ansinew]{inputenc}                                           % permite que los acentos del estilo \'a\'e\'i\'o\'u salgan joya
\usepackage[spanish, activeacute]{babel}                                 % idioma espaniol, acentos f\'aciles y deletreo de palabras
\usepackage{indentfirst}                                                 % permite indentar un parrafo a mano
\usepackage{caratula}                                                    % incluye caratula est\'andar
\usepackage{graphicx}                                                    % permite insertar gr\'aficos
\usepackage{color}                                                       % permite el uso de colores en el documento
\usepackage{amssymb}
\usepackage[pdfcreator={TexLive!, LaTeX2e con TeXnicCenter},
			pdfauthor={Grupo: "1"},
			pdftitle={Algoritmos III - Trabajo Pr\'actico 2},
			pdfsubject={Trabajo Pr\'actico 1},
			pdfkeywords={Prismas, Esferas, Punto de corte, puente, pizza},
			pdfstartview=FitH,            % Fits the width of the page to the window
			bookmarksnumbered,            % los bookmarks numerados se ven mejor...
			colorlinks,                   % links con bellos colores
			linkcolor=magenta]            % permite cambiar el color de los links
			{hyperref}                    % Permite jugar con algunas cosas que aparecer\'an en el PDF final

%RESTAURAR

\usepackage{algorithm}							% Permite tabular un codigo
\usepackage{algorithmic}
%\input{spanishAlgorithmic} % mi archivo de traducci\'on			

%\selectlanguage{spanish}

%\selectlanguage{spanish}
\linespread{1.3}                    % interlineado equivalente al 1.5 l\'ineas de Word...
\pagestyle{myheadings}              %encabezado personalizable con \markboth{}{}
\markboth{}{Algoritmos III  - Trabajo Pr\'actico 3 - Cammi, Garbi, Kretschmayer}
\headsep = 30pt                     % separaci\'on entre encabezado y comienzo del p\'arrafo

%\addtolength{\oddsidemargin}{-2cm}	% configuracion IDEAL!!!
%\addtolength{\textwidth}{4cm}
%\addtolength{\textheight}{2cm}

% macro 'todo' para To-Do's
\def\todo#1{\textcolor{red}{#1}}

% Macro 'borde' para un texto con borde
\newsavebox{\fmbox}
\newenvironment{borde}[1]
{\begin{lrbox}{\fmbox}\begin{minipage}{#1}}
{\end{minipage}\end{lrbox}\fbox{\usebox{\fmbox}}\\[10pt]}

%%%%%%%%%% FIN DEL PREAMBULO %%%%%%%%%%

\begin{document}

\materia{Algoritmos y Estucturas de datos III}
\submateria{Segundo Cuatrimestre de 2011}
\titulo{Trabajo Pr\'actico 3}
\subtitulo{Cartero Chino en grafo mixto.}
\grupo{Grupo: `1'}
\integrante{Cammi, Mart\'in}{676/02}{martincammi@gmail.com}
\integrante{Garbi, Sebasti\'an}{179/05}{garbyseba@gmail.com}
\integrante{Kretschmayer, Daniel}{310/99}{daniak@gmail.com}

\maketitle

\thispagestyle{empty}

\tableofcontents

\newpage


\textbf{Ejecuci\'on del TP}
\label{sec:ejecucion}

	\subsection{Lenguaje utilizado}
		
		El lenguaje utilizado para el trabajo pr\'actico ha sido \emph{Java}, compilando con la versi\'on 1.5 de la Virtual Machine.
		
		El trabajo se acompa\~{n}a con los fuentes de la soluci\'on que puede importarse en IDE de Eclipse o ejecutarse desde l\'inea de comandos.

	\subsection{Como ejecutar el TP}
	
	\textbf{\underline{Desde l\'inea de comandos}}
	\begin{itemize}
			\item{Posicionarse en el directorio Algo3Tp3}
			\item{Copiar all\'i el archivo de entrada para el problema i, por ejemplo Ej1.in}
			\item{Ejecutar el comando: \emph{java -cp ./bin problema1.Ej1}}
	\end{itemize}
	Esto generar\'a el archivo Ej1.out con la soluci\'on en el mismo directorio Algo3Tp3.

	\textbf{\underline{Desde el Eclipse}}
	
	Primero importaremos el proyecto:	
	
	\begin{itemize}
			\item{Seleccionar File $\Rightarrow$ Import.}
			\item{Seleccionar General $\Rightarrow$ Existing Projects into Workspace $\Rightarrow$ Next.}
			\item{Seleccionar el directorio llamado Algo3Tp3.}
			\item{Finish.}
	\end{itemize}
	
	Desde la vista de \textbf{Package Explorer} bajo el paquete \textbf{src} aparecer\'an tres paquetes más y dentro de cada uno de ellos los siguientes archivos de java:\\

	\begin{center}
		%\includegraphics[scale=0.65]{others/packageExplorer.png}\\
		COLOCAR IMAGEN CORRECTA
	\end{center}

\newpage

	Para ejecutar un problema:

	\begin{itemize}
			\item{Posicionarse en el directorio Algo3Tp3}
			\item{Copiar en el directorio Algo3Tp3 el archivo de entrada para el problema i, por ejemplo Ej1.in}
			\item{Con bot\'on derecho Run As $\Rightarrow$ Java Application. Se ejecutar\'a el problema seleccionado.}
	\end{itemize}
	Esto generar\'a el archivo Ej1.out con la soluci\'on en el mismo directorio Algo3Tp3.

\newpage


\section{Introducci\'on}

	En 1736 Leonhard Euler public\'o un trabajo en el cual resolv\'ia el denominado \emph{problema de los puentes de K\"{o}nigsberg}. La ciudad de K\"{o}ningsberg, actual Kaliningrado, Rusia, está dividida por el r\'io Pregel en 4 zonas, dos orillas (A y B), la isla de Kneiphof (C) y otras dos partes divididas por el río. (D y F). Las orillas estaban conectadas mediante 7 puentes. El problema consistía partir de una orilla y recorrer todos los puentes, recorri\'endo una sola vez cada uno y volviendo al punto de partida.\\

Este fu\'e el puntapié inicial para un tipo de problema que m'as adelante de modelar\'ia usando la teor\'ia de grafos. Este problema fue caracterizado por Euler y consist\'ia en encontrar un circuito que pasara por todas las aristas de un grafo una s\'ola vez volviendo al punto de partida.\\
 
M\'as de doscientos a\~{n}os m\'as tarde en 1962 el matemático chino Kwan Mei-Koo publicó un paper en el que abordaba un problema ligeramente similar, propon\'ia que si un grafo no pose\'ia un circuito Euleriano, podria quizás encontrar el circuito m\'as corto que pasara por todas las aristas aunque repitiera algunas de ellas. Este problema fue luego nombrado como "Problema del cartero chino".

\begin{center}
\centering \includegraphics[scale=0.70]{img/KaliningradoBridges.jpg}\\
\small{Imagen actual de la ciudad de Kaliningrado, en rojo figuran los puentes del problema original de K\"{o}nigsberg algunos cuales ya no existen hoy en d\'ia.}
\end{center}	

El problema tiene varias variantes, en este trabajo abordaremos la variante \emph{mixta} que consiste en intentar encontrar el m\'inimo circuito que pase por todas las aristas (no orientadas) y arcos (orientadas) de un grafo donde cada una tiene peso asignado.

\section{Situaciones de la vida real}

    El algoritmo del cartero chino tiene múltiples aplicaciones en la vida cotidiana por ser

	\begin{itemize}
	\item C\'alculo de rutas \'optimas para recorridos de camiones de basura: en donde los camiones deban recorrer las calles de una ciudad y volver al centro de tratamiento de basura. Las calles podr\'ian bien tener diferentes sentidos o sentidos únicos, y los pesos podr\'an corresponder a la cantidad de basura que deban recolectar en ciertas zonas.
	\end{itemize}


\section{Heurística Constructiva}
	Para la etapa constructiva, hemos realizado en primer lugar, una orientaci\'on de todas las aristas utilizando 5 maneras distintas, todas ellas con respecto a los grados de los nodos. Entonces, seg\'un un par\'ametro de entrada que indica cual de estas opciones usar\'a, encontrar\'a los nodos del grafo que cumplan lo siguiente, pas\'andole otro par\'ametro y buscar\'a: 
	
	\begin{itemize}
	
	\item Los nodos que tienen igual cantidad de aristas sin orientar que orientadas, y en caso de haber muchos, solo tomar\'a los primeros k nodos de ellos, donde k es el par\'ametro de entrada de la funci\'on.
	\item Los nodos a partir de un cierto n\'umero, que es definido por el par\'ametro de entrada de la funci\'on.
	\item Los nodos que tengan grado de nodo (sin orientar) mayor o igual al par\'ametro de entrada de la funci\'on.
	\item Los nodos que tengan grado de entrada (orientado) mayor o igual al par\'ametro de entrada de la funci\'on.
	\item Los nodos que tengan grado de salida (orientado) mayor o igual al par\'ametro de entrada de la funci\'on.
 
  \end{itemize}
  
  En caso de no encontrar ning\'un nodo a orientar con estas opciones, encontr\'a los k primeros nodos (empezando desde 0), sea cual sea el grado de sus nodos.
  Con cualquiera de estas posibilidades, siempre se intenta hacer un balance entre los grados que quedar\'an (solo quedar\'an grados de entrada y salida, ya que ser\'a completamente orientado). Esta decisión se basa, que luego le calcularemos el circuito Euleriano al grafo resultante, para poder encontrar un circuito que pase por todas las aristas. Una vez que tenemos todo el grafo orientado, realizamos luego una etapa de matching entre los nodos que quedan con diferentes grado de entrada y de salida, y balanceamos a todos los nodos, para que queden con iguales grados de entrada como de salida, y el grafo queda Euleriano. Este matching lo calculamos con la distancia m\'inima de entre cada uno de los nodos, pero en el grafo original, por lo que todas las aristas agregadas, tienen distancia m\'inima entre ellas.
	
\section{Heurística de busqueda Local}
En nuestra b\'usqueda local, lo que realizaremos es cambiar el matching que hace entre los nodos, para obtener otro donde sea  m\'inimo y as\'i poder acercarnos mejor a la soluci\'on requerida. Notemos que, como los matching entre los nodos donde se ten\'ia que los grados de entrada y de salida no coincid\'ian se efect\'ua sobre el grafo original (y no con el orientado), esta es una soluci\'on \'optima para esa orientaci\'on. Luego, con el grafo totalmente orientado y Euleriano, simplemente se calcula el peso de todas las aristas, y llegamos al peso del camino requerido.\\

//DESDE ACA ES LO QUE HABIA
Nuestro algoritmo de busqueda local se basa en eliminar aristas y arcos agregados para igualar los grados de salida a los de entrada de algunos nodos y cambiarlos por un conjunto de aristas que cumplen la misma propiedad pero cuya suma es menor.
Para ello el algoritmo constructivo realiza los siguientes pasos dado un grafo mixto:

1) Orientar todas las aristas no orientadas del grafo.
2) Calcular un matching entre los nodos que tengan din != dout.
3) Calcular el peso del camino m\'inimo entre los nodos del matching.

4) Calcular los caminos m\'inimos entre cada par del matching y con ellos y armar el Circuito euleriano.
//DESDE ACA ES LO QUE HABIA

\section{Metaheuristica Grasp}
\section{Complejidad}
Complejidades donde $n$ es la cantidad de nodos, $m_{1}$ la cantidad de aristas, $m_{2}$ la cantidad de arcos y $m$ = $m_{1} + m_{2}$ \\
\begin{itemize}
	\item Inicializar grafo (lectura de archivo)
	\begin{itemize}
		\item Inicializar la matriz de pesos $O(n^{2})$
		\item Inicializar las listas de adyacencias $O(n + m_{1} +m_{2})$
	\end{itemize}
	$O(n^{2} + m_{1} +m_{2}) \subseteq O(n^{2})$
	\item fuertementeConexo
	\begin{itemize}
		\item Inicializacion de listas de adyacencias $O(n + m_{1} + m_{2})$
		\item resetVisitados y checkVisitados recorren un array de bools de tamaño cantNodos $O(n)$
		\item visitarNodos recorre recursivamente en DFS las adyacencias y marca los nodos que son accesibles desde el nodo $0$ $O(m_{1} + m_{2})$
	\end{itemize}
	$O(n + m_{1} + m_{2})$
	\item Calcular Dantzig
	\begin{itemize}	
		\item Inicializacion de la matriz de pesos de caminos minimos $O(n^{2})$
		\item 3 for anidados de $0$ a $n$ con operaciones de tiempo constante $O(n^{3})$
	\end{itemize}
	$O(n^{3})$
	\item sumaPesosEjes recorre todas las aristas y arcos de los nodos $O(m_{1} + m_{2})$
	\item Clonar el grafo $O(n^{2} + m_{1} + m_{2})$ para copiar las estructuras
	\item orientarTodasAristas
	\begin{itemize}
		\item $m_{1}$ iteraciones de
		\begin{itemize}
			\item encontrarNodoAOrientar: Busca cuales nodos cumplen la condicion dada $O(n)$
			\item eleccionNodoAOrientar: Elije segun el parametro pasado por cual nodo de la lista anterior va a continuar $O(n)$
			\item orientarNodo $O(1)$
		\end{itemize}
		$O(1+ n+ n) subset O(n)$
	\end{itemize}
	$O(m_{1} * n)$
	\item encontrarMatchingNodos
	\begin{itemize}
		\item inicializacion de arreglos de longitud $n$ $O(n)$
		\item para cada exedente de $Din$ arma una pareja con un $Dout$ y lo agrega en una lista con el peso calculado con $Dantzig$ $O(\sum_{i=1}^{n}{|din(i)-dout(i)|}/2)$ $\subseteq$ $O(m)$
	\end{itemize}
	$O(m + n)$
	\item encontrarMatchingDeMenorPeso: Dado un matching de tamaño $k$ devuelve el mejor matching que se puede obtener swapeando los destinos de solo dos items del matching original. $O(k^{2})$
	\item pesoMatching recorre una lista de tamaño a lo sumo $m$ $O(m)$
	\item agregarCaminosMatcheados
	\begin{itemize}
		\item inicializacion de matriz de tamaño $n*n$ $O(n^{2})$
		\item Para cada eje $(i,j)$ del matching (a lo sumo $m$ ejes)
		\begin{itemize}
			\item Si no esta calculado el $Dijkstra$ para el nodo $i$ $\rightarrow$ Calcula $Dijkstra$ sobre el grafo original y lo guarda $O(n^{2})$
			\item Recuperar el camino del $Dijkstra$ calculado para el nodo $i$ hasta el nodo $j$ $O(n)$
		\end{itemize}
		$O(n^{2})$ Si no esta calculado $Dijkstra$ (a lo sumo $n$ casos)\\
		$O(n)$ Si ya esta calculado $Dijkstra$
	\end{itemize}
	$O(m*n + n*n^{2})$ como $O(m)$ $\subseteq$ $O(n^{2})$ $\Rightarrow$ $O(m*n + n^{3})$ $\subseteq$ $O(n^{3})$
	\item Dijkstra
	\begin{itemize}
		\item Inicializacion de arreglos de int y bool de tamaño $n$ $O(n)$
		\item Para cada nodo $i$ ($n$ elementos)
		\begin{itemize}
			\item Minvertex $O(n)$
			\item Para cada adyacente del nodo $i$ actualiza el valor $O(d(i))$
		\end{itemize}
	\end{itemize}
	$O(n + \sum_{i=1}^{n}{(d(i) + n)})$ $\subseteq$ $O(n + 2*m + n*n)$ $\subseteq$ $O(n^{2})$
	\item encontrar circuito euleriano $O(2 * largo del circuito)$\\
	Donde largo del circuito puede ser en peor caso $m*n$ cuando todos los nodos tiene matching y todos los caminos agregados tiene longitud $n$\\
	$O(m*n)$
\end{itemize}
\newpage

\begin{algorithm}
	\caption{Main($grafo$)}
	\begin{algorithmic}
	\STATE Grafo $GrafoOriginal$ $\gets$ Inicializar con instancia
	\IF{ es fuertemente Conexo $GrafoOriginal$}
		\STATE $PesosCaminosMinimos$ $\gets$ calcularDantzig($GrafoOriginal$)
		\STATE $SumaOriginalPesos$ $\gets$ sumaPesosEjes($GrafoOriginal$)
		\STATE $SumaSolucionMejor$ $\gets$ $\infty$
		\STATE $GrafoCopiaMejor$ $\gets$ $NULL$
		\STATE $MatchingMejor$ $\gets$ $\emptyset$
		\WHILE{ no se alcanzan $MaximoIteracionesGrasp$ $\lor$ $MaximoIteracionesSinMejoraGrasp$}
			\STATE Grafo $GC$ $\gets$ copiarGrafo($GrafoOriginal$)
			\STATE $ParametroGRASP$ $\gets$ Random
			\STATE orientarTodasAristas($GC$,$ParametroGRASP$)
			\STATE $matching$ $\gets$ encontrarMatchingNodos($GC$,$ParametroGRASP$)
			\WHILE{ no se alcanza $MaximoIteracionesBusquedaLocal$ $\lor$ no se encontro un matching optimo}
				\STATE $matching$ $\gets$ encontrarMatchingDeMenorPeso($matching$,$pesosCaminosMinimos$)
			\ENDWHILE
			\STATE $pesoMatching$ $\gets$ pesoMatching($matchingMejor$)
			\STATE $sumaSolucion$ $\gets$ $pesoMatching + SumaOriginalPesos$
			\IF{ mejoro la solucion }
				\STATE $SumaSolucionMejor$ $\gets$ $sumaSolucion$
				\STATE $GrafoCopiaMejor$ $\gets$ $GC$
				\STATE $MatchingMejor$ $\gets$ $matching$
			\ENDIF
		\ENDWHILE
		\STATE agregarCaminosMatcheados($GrafoCopiaMejor$,$MatchingMejor$,$GrafoOriginal$)
		\STATE $circuito$ $\gets$ encontrarCircuitoEuleriano($GrafoCopiaMejor$)
		\RETURN $circuito$
	\ELSE
		\RETURN No hay Tour porque el grafo no era fuertemente conexo
	\ENDIF
	\end{algorithmic}
\end{algorithm}

Complejidad:
	\begin{itemize}
	\item $O(n^{2})$ de inicializacion
	\item $O(n + m_{1} + m_{2})$ de fuertementeConexo
	\item $O(n^{3})$ de Dantzig
	\item $O(m_{1} + m_{2})$ de sumarPesosEjes
	\item $MaximoIteracionesGrasp$*
	\begin{itemize}
		\item $O(n^{2} + m_{1} + m_{2})$ de copiar el grafo
		\item $O(m_{1} * n)$ de orientarTodasLasAristas
		\item $O(m_{1} + m_{2} + n)$ de encontrarMatchingNodos
		\item $MaximoIteracionesBusquedaLocal$*
		\begin{itemize}
			\item $O(m^{2})$ de encontrarMatchingDeMenorPeso
		\end{itemize}
		\item $O(m)$ de calcular peso del matching
	\end{itemize}
	\item $O(n^{3})$ de agregarCaminosMatcheados
	\item $O(m*n)$ de encontrar el CircuitoEuleriano
	\end{itemize}
Para grafos que no son fuertemente conexos la complejidad es $O(n^{2} + m)$\\	
Para las instancias interesantes del problema la complejidad esta dada por:
$O(n^{2} + n + m + n^{3} + m + \\MaximoIteracionesGrasp*(n^{2} + m + m_{1} * n + m + n + MaximoIteracionesBusquedaLocal*(m^{2}) + m ) + n^{3} + m*n)$ $\subseteq$
$O(n^{3} + m^{2} + m*n)$ $\subseteq$ $O(n^{3} + m^{2})$\\
%Como sabemos que el grafo es fuertemente conexo $\Rightarrow$ $ O(n) \subseteq O(m)$ $\Rightarrow$ la complejidad es\\
%$O(n^{3} + m^{2})$ $\subseteq$ $O(n*m^{2})$
\\
Definimos el tamaño de entrada como:
	\begin{center}	
	$T = log(n) + log(m_{1}) + log(m_{2}) + \sum_{i=1}^{m_{1} + m_{2}}{(log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}))}$\\
	Como $log(n) + log(m_{1}) + log(m_{2}) > 0 \Rightarrow$\\
	$T > \sum_{i=1}^{m_{1} + m_{2}}{(log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}))}$\\
	Tambien sabemos que para cada eje $log(arista_{i_{nodo1}})+log(arista_{i_{nodo2}}) + log(arista_{i_{peso}}) > 1 \Rightarrow$\\
	$T > \sum_{i=1}^{m_{1} + m_{2}}{1} = m_{1} + m_{2} = m$ \\
	Sabemos que el grafo es fuertemente conexo asi que $n$ es del orden de $m$ $\Rightarrow$\\
	$T > m \geq n$ \\
	Dado la complejidad calculada y las cotas para $T$ vale $O(n^{3} + m^{2})$ $\subseteq$ $O(T^{3}+T^{2})$ $\subseteq$ $O(T^{3})$
	\end{center}
\end{document}
